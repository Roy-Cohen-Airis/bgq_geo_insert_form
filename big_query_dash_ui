import dash
import dash_bootstrap_components as dbc
import dash_leaflet as dl
from dash import html, Input, Output
from dash import dcc
from dash import dash_table
from dash.dash_table import DataTable
import dash.exceptions as dash_exceptions
import random

import os
import re
import math
import ast
import numpy as np
import pandas as pd
import json

import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
from pathlib import Path
from dash import dcc, html, Input, Output, State
from dash.exceptions import PreventUpdate
import yt_dlp
import warnings
from openai import OpenAI
import base64
import io
import requests
import time
import dash_player
from dash import callback_context
from shapely.geometry import Point, Polygon
import datetime    
from datetime import timedelta
from datetime import date

# Google API imports
from googleapiclient.discovery import build
from google.oauth2.service_account import Credentials
from oauth2client.client import GoogleCredentials
from google.oauth2 import service_account
from google.cloud import bigquery


warnings.filterwarnings("ignore", message="pandas only supports SQLAlchemy connectable")


SERVICE_ACCOUNT_FILE = r"arabic-transcription-435113-c8120df00a35.json"
bq_service_account = r"C:\Users\roy\OneDrive\Desktop\ASR JSONS\Geo_Analysis\airis-rnd-machines-c514798d388f.json"


SCOPES = ['https://www.googleapis.com/auth/spreadsheets']
credentials = Credentials.from_service_account_file(SERVICE_ACCOUNT_FILE, scopes=SCOPES)
service = build('sheets', 'v4', credentials=credentials)
# Define scopes
SCOPES = ['https://www.googleapis.com/auth/spreadsheets.readonly', 
          'https://www.googleapis.com/auth/drive']

# Authenticate
creds = service_account.Credentials.from_service_account_file(
    SERVICE_ACCOUNT_FILE, scopes=SCOPES)

# Build Sheets API service
service = build('sheets', 'v4', credentials=creds)
sheet = service.spreadsheets()


# Define the required scopes
SCOPES = ['https://www.googleapis.com/auth/drive']

# Authenticate using Service Account
creds = service_account.Credentials.from_service_account_file(SERVICE_ACCOUNT_FILE, scopes=SCOPES)

# Build the Drive API service
drive_service = build('drive', 'v3', credentials=creds)

app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])
app.title = "Annotation Form"

def load_api_key(filepath=r"gpt_key.txt"):
    with open(filepath, 'r') as file:
        return file.read().strip()

apikey = load_api_key()

clients = OpenAI(api_key= apikey)

def get_bq_client():
    return bigquery.Client() 


button_style1 = {
    "borderRadius": "24px",
    "width": "250px",
    "padding": "15px 25px",
    "position": "absolute",
    "bottom": "30px",
    "right": "30px",
    "background": "linear-gradient(to right, #4facfe, #00f2fe)",
    "border": "2px solid black",
    "fontWeight": "600",
    "fontSize": "40px",
    "font-weight": 'bold',
    "color": "white",
    "textAlign": "center",
    "boxShadow": "0 8px 16px rgba(0, 0, 0, 0.2)",
    "transition": "all 0.3s ease-in-out"
}

button_style2 = {
    "borderRadius": "24px",
    "width": "250px",
    "padding": "15px 25px",
    "background": "linear-gradient(to right, #006400, #98FB98)",
    "border": "2px solid black",
    "fontWeight": "bold",
    "fontSize": "24px",
    "color": "white",
    "textAlign": "center",
    "boxShadow": "0 8px 16px rgba(0, 0, 0, 0.2)",
    "transition": "all 0.3s ease-in-out"
}

button_style3 = {
    "borderRadius": "24px",
    "width": "250px",
    "padding": "15px 25px",
    "background": "linear-gradient(to right, #B22222, #F08080)",
    "border": "2px solid black",
    "fontWeight": "bold",
    "fontSize": "24px",
    "color": "white",
    "textAlign": "center",
    "boxShadow": "0 8px 16px rgba(0, 0, 0, 0.2)",
    "transition": "all 0.3s ease-in-out",

}

button_style4 = {
    "padding": "5px 10px",
    "border": "2px solid black",
    "fontWeight": "bold",
    "fontSize": "24px",
    "textAlign": "center",
    "boxShadow": "0 8px 16px rgba(0, 0, 0, 0.2)",
    "position": "relative",
    "top": "350px"
}

rec_num = {
    "fontWeight": "bold",
    "fontSize": "18px",
    "textAlign": "center",
    "position": "relative",
    "top": "285px"       
}

save_link_btn = {
    "padding": "5px 10px",
    "border": "2px solid black",
    "fontWeight": "bold",
    "background-color":'orange',
    "fontSize": "16px",
    "textAlign": "center",
    "boxShadow": "0 8px 16px rgba(0, 0, 0, 0.2)",
    "position": "relative",
    "top": "385px",
    "borderRadius": "50px",
}

link_check = {
    "padding": "5px 10px",
    "border": "2px solid black",
    "fontWeight": "bold",
    "background-color":'purple',
    "fontSize": "16px",
    "textAlign": "center",
    "boxShadow": "0 8px 16px rgba(0, 0, 0, 0.2)",
    "position": "relative",
    "top": "400px",
    "borderRadius": "50px",
}

place_map_btn = {
    "padding": "5px 10px",
    "border": "2px solid black",
    "fontWeight": "bold",
    "background-color":'blue',
    "fontSize": "16px",
    "textAlign": "center",
    "boxShadow": "0 8px 16px rgba(0, 0, 0, 0.2)",
    "position": "relative",
    "right": "100px",
    "top": "640px",
    "borderRadius": "50px",
}

check_location=  {
    "padding": "5px 10px",
    "border": "2px solid white",
    "fontWeight": "bold",
    "background-color":'black',
    "fontSize": "16px",
    "textAlign": "center",
    "boxShadow": "0 8px 16px rgba(0, 0, 0, 0.2)",
    "position": "relative",
    "top": "675px",
    "borderRadius": "50px",
}

check_btn_ed = {
    "padding": "5px 10px",
    "border": "2px solid black",
    "fontWeight": "bold",
    "background-color":'blue',
    "fontSize": "16px",
    "textAlign": "center",
    "boxShadow": "0 8px 16px rgba(0, 0, 0, 0.2)",
    "position": "relative",
    "top": "600px",
    "left": "-50px",
    "borderRadius": "50px",
}


check_div ={
   "top": "985px", 
}
background_style = {
    "background": "linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)",
    "minHeight": "auto",
    "padding": "20px"
}

container_style = {
    "backgroundColor": "white",
    "borderRadius": "30px",
    "padding": "30px",
    "boxShadow": "0 10px 40px rgba(0, 0, 0, 0.1)",
    "width": "100%",
    "maxWidth": "2400px",
    "margin": "auto",
    "position": "relative"
}

container_style_2 = {
    "backgroundColor": "white",
    "borderRadius": "30px",
    "padding": "30px",
    "boxShadow": "0 10px 40px rgba(0, 0, 0, 0.1)",
    "width": "100%",
    "maxWidth": "2400px",
    "margin": "auto",
    "position": "relative"
}

heading_style = {
    "textAlign": "center",
    "fontFamily": "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen",
    "color": "#333",
    "fontSize": "48px",
    "marginBottom": "30px"
}

heading_style2 = {
    "textAlign": "center",
    "fontFamily": "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen",
    "color": "#333",
    "fontSize": "28px",
    "marginBottom": "30px"
}

tab_style = {
    "backgroundColor": "#E0FFFF",
    "borderRadius": "12px 12px 0 0",
    "padding": "10px 20px",
    "fontSize": "32px",
    "color": "#555",
    "border": "none",
    "fontWeight": "500"
}

selected_tab_style = {
    "backgroundColor": "#00f2fe",
    "borderBottom": "2px solid #00f2fe",
    "fontWeight": "bold",
    "color": "white",
    "fontSize": "32px"
}

modal_style = {
    "color": "#333",
    "fontSize": "20px",
    "padding": "10px",
    "fontWeight": "500"
}

update_modal_style = {"textAlign": "center"}



def append_row_to_bq(row_data, table_id):
    """
    Appends a row to a BigQuery table.
    table_id: str, e.g., 'project_id.dataset_id.table_name'
    """
    client = get_bq_client()
    table = client.get_table(table_id)

    row = dict(zip([field.name for field in table.schema], row_data))

    errors = client.insert_rows_json(table, [row])
    if errors:
        print(f"❌ Error inserting row: {errors}")
    else:
        print("✅ Row inserted into BigQuery.")


def remove_record_bq(cut_id, table_id):
    client = get_bq_client()
    print(client)
    sql = f"""
        DELETE FROM `{table_id}`
        WHERE `Cut_ID` = @Cut_ID
    """
    job_config = bigquery.QueryJobConfig(
        query_parameters=[
            bigquery.ScalarQueryParameter("Cut_ID", "STRING", cut_id)
        ]
    )

    query_job = client.query(sql, job_config=job_config)
    query_job.result()
    print(f"✅ Row with Cut_ID {cut_id} deleted from BigQuery.")

  
   
     
def is_valid_coord(coord_str):
    numbers = re.findall(r'[-+]?\d*\.\d+|[-+]?\d+', str(coord_str))
    return len(numbers) >= 2

def clean_coordinate(coord_str: str) -> str:
    # Extract numbers (handles both integers and floats, including optional + or -)
    numbers = re.findall(r'[-+]?\d*\.\d+|[-+]?\d+', coord_str)
    if len(numbers) < 2:
        raise ValueError("Not enough coordinate numbers found in the input.")
    # Return the first two numbers separated by a comma
    return f"{numbers[0]},{numbers[1]}"

def parse_input_time(time_str):
    # Assume format is M:S
    parts = [p.strip() for p in time_str.split(':')]
    if any(p == '' for p in parts):
        raise ValueError(f"Invalid time string: {time_str}")
    if len(parts) != 3:
        raise ValueError("Expected format MM:SS")
    return timedelta(minutes=int(parts[0]), seconds=int(parts[1]))

def parse_duration(duration_str: str) -> timedelta:
    parts = duration_str.strip().split(":")
    if len(parts) == 3:                 # HH:MM:SS
        hours, minutes, seconds = map(int, parts)
    elif len(parts) == 2:               # MM:SS  →  assume hours = 0
        hours = 0
        minutes, seconds = map(int, parts)
    else:
        raise ValueError(
            "Expected duration format MM:SS or HH:MM:SS "
            f"(got ‘{duration_str}’)"
        )

    # Basic sanity check
    if not (0 <= minutes < 60 and 0 <= seconds < 60):
        raise ValueError("Minutes and seconds must be in the range 0-59")

    return timedelta(hours=hours, minutes=minutes, seconds=seconds)


def is_valid_social_url(url: str) -> bool:
    patterns = {
        "youtube": re.compile(
            r'^(https?://)?(www\.)?'
            r'(youtube\.com/(watch\?v=|shorts/)|youtu\.be/)'
            r'[\w-]{11}($|&)', re.IGNORECASE
        ),
        "instagram": re.compile(
            r'^(https?://)?(www\.)?instagram\.com/(p|reel|tv)/[A-Za-z0-9_-]+/?$', re.IGNORECASE
        ),
        "telegram": re.compile(
            r'^(https?://)?(t\.me|telegram\.me)/[A-Za-z0-9_]{5,32}/?$', re.IGNORECASE
        ),
        "facebook": re.compile(
            r'^(https?://)?(www\.)?facebook\.com/(?:[^/?#&]+/)*[^/?#&]+/?$', re.IGNORECASE
        ),
        "tiktok": re.compile(
            r'^(https?://)?(www\.)?tiktok\.com/@[A-Za-z0-9_.]+/video/\d+/?$', re.IGNORECASE
        )
    }

    return any(pattern.match(url) for pattern in patterns.values())

def general_validations (analyst,city_name,distancebuild,title,occlusion,terrain,
                         logo,distortions, tod,weather,vq,tilt,sources,scenes):
    if not analyst or analyst== "Select Analyst":
        raise ValueError("Please select an Analyst!")
    if not city_name:
        raise ValueError("Please select a City!")            
    if not distancebuild or distancebuild=='Select a distance ' :
        raise ValueError("Please Insert Distance from building!")
    if not title or title == 'Title Not Found! Please insert manually!':
        raise ValueError("Please Insert Title!")
    if not occlusion or occlusion == "Select an occlusion":
        raise ValueError("Please Insert Occlusion!")
    if not terrain or terrain == "Select a terrain":
        raise ValueError("Please Insert Terrain!")  
    if not logo or logo == 'Select Logos & Text':
        raise ValueError("Please Insert Logos & Text!")    
    if not distortions or distortions == 'Select a Distortion ':
        raise ValueError("Please Insert Distortions!") 
    if not tod or tod == "Select time of day":
        raise ValueError("Please Insert Time of Day!")  
    if not weather or weather == "Select weather ":
        raise ValueError("Please Insert Weather!")  
    if not vq or vq== "Select video quality":
        raise ValueError("Please Insert Video Quality!")                     
    if not tilt or tilt == 'Select camera tilt ':
        raise ValueError("Please Insert Camera Tilt!")
    if not sources or sources == 'Select a source':
        raise ValueError("Please Insert Source!")
    if not scenes or scenes == 'Pick Scene':
        raise ValueError("Please Pick Scene/s!")   
    
def is_valid_url (url):
    if not url:
        raise ValueError("Please insert a url!")
    else:
        valid_url = is_valid_social_url(url)
        if not valid_url:
            raise ValueError("Please insert a valid social url!")
        return url  

def is_valid_url_silent(url):
    if not url:
        return False
    valid_url = is_valid_social_url(url)
    return valid_url

def valid_coords(coords):
    if not coords:
        raise ValueError("Please insert coordinates!")
    if not is_valid_coord(coords):
        raise ValueError("Invalid Coordinates!")
    cleaned_coordinates =  clean_coordinate(coords)
    return cleaned_coordinates

def valid_dur(duration):
    if not duration:
        raise ValueError("Please insert duration!")
    if duration == "Invalid duration!":
        raise ValueError("Invalid Duration!")
    return duration
               
def parse_time_string(time_str):
    parts = list(map(int, time_str.strip().split(':')))
    if len(parts) == 3:
        hh, mm, ss = parts
    elif len(parts) == 2:
        hh = 0
        mm, ss = parts
    elif len(parts) == 1:
        hh = mm = 0
        ss = parts[0]
    else:
        raise ValueError(f"Invalid time format: {time_str}")
    return hh, mm, ss

# Check inside polygon
def is_inside_any(lat, lon, polygons):
    pt = Point(lat, lon)
    if polygons and Polygon(polygons).contains(pt):
            return True
    return False
    


def city_load_data(query: str) -> pd.DataFrame:
    """
    Runs a SQL query on BigQuery and returns results as a pandas DataFrame.
    """
    client = bigquery.Client()
    try:
        query_job = client.query(query)
        df = query_job.result().to_dataframe()
    except Exception as e:
        print(f"❌ Error loading data from BigQuery: {e}")
        df = pd.DataFrame()
    return df

from google.cloud import bigquery
import pandas as pd

def advanced_city_load (table: str, column: str, value) -> pd.DataFrame:
    """
    Runs a parameterized SQL query on BigQuery:
    SELECT * FROM {table} WHERE {column} = {value}
    Returns results as a pandas DataFrame.
    """
    client = bigquery.Client()
    try:
        query = f"SELECT * FROM `{table}` WHERE {column} = @value"
        job_config = bigquery.QueryJobConfig(
            query_parameters=[
                bigquery.ScalarQueryParameter("value", "STRING", value)
            ]
        )
        query_job = client.query(query, job_config=job_config)
        df = query_job.result().to_dataframe()
    except Exception as e:
        print(f"❌ Error loading data from BigQuery: {e}")
        df = pd.DataFrame()
    return df


global df_city_edit
df_city_edit = city_load_data("SELECT * FROM `airis-rnd-machines.Sample_Data.Geo_App_DB`")
global cities
cities = city_load_data("SELECT * FROM `airis-rnd-machines.Sample_Data.Cities DB`")
cities_list = cities['City_Name'].unique()
country_list = cities['Country'].unique()



source_list = df_city_edit['Source'].unique()
time_list = df_city_edit['Time_of_the_day'].unique()
terrain_list = df_city_edit['Terrain'].unique()
weather_list = df_city_edit['Weather'].unique()
scene_description = ['Protests/Demonstrations','Crowd gathering in the street','March','Crime scene','Tourist tour','News interview','None']
video_vq = df_city_edit['Video_quality'].unique()
camera_tilt = df_city_edit['Camera_tilt'].unique()
distance = df_city_edit['Distance_from_building'].unique()
occlusion = df_city_edit['Occluded'].unique()
distortions = df_city_edit['Distortions'].unique()
logos = df_city_edit['Logos_and_text'].unique()
analysts =df_city_edit['Analyst'].unique()


import datetime

def parse_time(t):
    if isinstance(t, datetime.time):
        h, m, s = t.hour, t.minute, t.second
    elif isinstance(t, str):
        parts = list(map(int, t.split(':')))
        if len(parts) == 3:            # HH:MM:SS
            h, m, s = parts
        elif len(parts) == 2:          # MM:SS
            h, m, s = 0, *parts
        else:
            raise ValueError('Bad time format')
    else:
        raise TypeError(f"Unsupported time type: {type(t)}")
    
    return datetime.timedelta(hours=h, minutes=m, seconds=s)



import random

def generate_unique_random_id(city, df, url):
    df_filtered = df[df['City'] == city].copy()

    # Create a set of existing record_id prefixes for efficient lookup
    existing_prefixes = set(rec_id.split('_', 2)[0] + '_' + rec_id.split('_', 2)[1] + '_' for rec_id in df['Cut_ID'].values)

    def create_random_initials():
        country_name = cities[cities['City_Name'] == city]['Country'].values[0].lower()
        city_name = city.lower()

        # Ensure the names are long enough for sampling
        if len(country_name) < 2 or len(city_name) < 3:
            raise ValueError("Country or city name too short for random sampling.")

        init_1 = ''.join(random.sample(country_name, 2))
        init_2 = ''.join(random.sample(city_name, 3))
        return f"{init_1}_{init_2}_"

    if df_filtered.empty:
        # Default deterministic initials
        country_name = cities[cities['City_Name'] == city]['Country'].values[0]
        init_1 = f"{country_name[:2].lower()}_"
        init_2 = f"{city[:3].lower()}_"
        initials = init_1 + init_2

        # If deterministic initials are already used, generate random ones
        if initials in existing_prefixes:
            max_tries = 1000
            for _ in range(max_tries):
                initials = create_random_initials()
                if initials not in existing_prefixes:
                    break
            else:
                raise RuntimeError("Failed to find unique initials after many attempts.")

        # Generate unique numeric part and return
        xyz = f"{random.randint(9, 99)}{random.randint(9, 99)}{random.randint(99, 999)}"
        joined = initials + xyz
        new_rec_id = f"{joined}_cut1_v1"
        return new_rec_id

    else:
        df_filt2 = df[df['Links'] == url].copy()
        if not df_filt2.empty:
            df_filt2['base'] = df_filt2['Cut_ID'].str.extract(r'^(.*)_v\d+$')[0]
            df_filt2['version'] = df_filt2['Cut_ID'].str.extract(r'_v(\d+)$')[0].astype(int)
            
            latest_versions = df_filt2.sort_values('version').groupby('base', as_index=False).last()

            url_times = latest_versions['base'].nunique()  # <-- Count different cuts (bases)

            extra_cut = url_times + 1
            new_cut_id = f"cut{extra_cut}"

            id_video = df_filt2['record_id'].values[0]  # Assuming record_id is same for all versions
            new_rec_id = f"{id_video}_{new_cut_id}_v1"

        else:
            # Generate from last record_id for existing city
            rec_id = df_filtered['Cut_ID'].iloc[-1]
            rec_id_start = '_'.join(rec_id.split('_')[:2]) + '_'

            while True:
                xyz = f"{random.randint(9, 99)}{random.randint(9, 99)}{random.randint(99, 999)}"
                new_rec = rec_id_start + xyz
                if new_rec not in df_filtered['record_id'].values:
                    new_rec_id = f"{new_rec}_cut1_v1"
                    return new_rec_id
        return new_rec_id

cleaned_source = [v for v in source_list if v not in ("", None)]  
cleaned_distance = [v for v in distance if v not in ("","Street level", None)]   
cleaned_occlusion = [v for v in occlusion if v not in ("", None)] 
cleaned_logos = [v for v in logos if v not in ("","slight ", "Prominent ", None)] 
cleaned_distortions = [v for v in distortions if v not in ("","Motion DIstortions","No", None)] 
cleaned_vq = [v for v in video_vq if v not in ("", None)] 
cleaned_tilt = [v for v in camera_tilt if v not in ("", None)] 
insert_mode = ['Manual','ChatGPT Suggestion']

def insert_tab_layout():
    return html.Div(
        style=background_style,
        children=[
            dbc.Container(
                style=container_style,
                children=[
                dcc.Store(id='default-values', data={
                    'link_url': "",
                    "coordinates_input": "",
                    'sources': "Select a source",
                    'input-hours': 0,
                    'input-minutes': 0,
                    'input-seconds': 0,
                    'input-hours_end': 0,
                    'input-minutes_end': 0,
                    'input-seconds_end': 0,
                    'tod': 'Select time of day',
                    'weather': "Select weather ",
                    'scene_desc': "Pick Scene",
                    'vq': "Select video quality",
                    'tilt': 'Select camera tilt ',
                    'distance': 'Select a distance ',
                    'occlusion_list': 'Select an occlusion',
                    'terrain': "Select a terrain",
                    'logos_list': 'Select Logos & Text',
                    'distortions_list': 'Select a Distortion ',
                    'analysts': 'Select Analyst',
                    'comments':""
                }),
                dcc.Store('links_table_store',data=None),
                dcc.Store('poly_store',data=None),
                dcc.Store(id="insert_guard", data={"pending": False, "cooldown_until": 0}),
                dcc.Store(id="insert_trigger", data=None),

                    html.H1("Geo Annotation Form", style=heading_style),
                    html.Hr(),
                    dbc.Row([
                        # First Column
                        dbc.Col([
                            html.H4("Link & Coordinates"),
                            dbc.Label("Choose a city:"),
                            dcc.Dropdown(
                                id='cities',
                                options=[{'label': k, 'value': k} for k in cities_list],
                                value="Rome",
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Country:"),
                            dcc.Dropdown(
                                id='country',
                                options=[{'label': k, 'value': k} for k in country_list],
                                value="Italy",
                                placeholder='country selection',
                                className="form-control",
                                disabled=True,
                            ),
                            html.Br(),
                            dbc.Label("Pick a source:"),
                            dcc.Dropdown(
                                id='sources',
                                options=[{'label': d, 'value': d} for d in cleaned_source],
                                value="",
                                placeholder = "Select a source",
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Video Link:"),
                            dcc.Input(id='link_url', type='text', value="", className="form-control"),
                            html.Div(id="link_url_error", style={"color": "red"}),
                            html.Br(),
                            dbc.Label("Video Title:"),
                            dcc.Input(id='link_title', type='text',disabled=True, value="", className="form-control"),  
                            html.Br(),  
                            dbc.Label("Coordinates Insert Mode:"),
                            dcc.Dropdown(
                                id='insert_type',
                                options=[{'label': d, 'value': d} for d in insert_mode],
                                value='Manual',
                                placeholder = "Pick An Insert Mode",
                                className="form-control"
                            ),      
                                dcc.Upload(
                                id='upload-image',
                                children=html.Div(['Drag and Drop or ', html.A('Select Image')]),
                                
                                style={
                                    'width': '100%',
                                    'height': '60px',
                                    'lineHeight': '60px',
                                    'borderWidth': '1px',
                                    'borderStyle': 'dashed',
                                    'borderRadius': '5px',
                                    'textAlign': 'center',
                                    'margin': '10px',
                                    'display': 'None' 

                                },
                                multiple=False
                            ),
                            html.Div(id='output-image-upload') ,           
                            dbc.Label("Coordinates:"),
                            dcc.Input(id='coordinates_input', type='text', value="", className="form-control"),
                            html.Div(id="coords_error", style={"color": "red"}),
                            html.Br(),
                            dbc.Label("Auto-Generated Coordinates Location:"),
                            dcc.Input(id='gen_loc', type='text', disabled=True, className="form-control"), 
                            html.Br(),
                            dbc.Label("Nearby Coordinates Radius (Meters):"),
                            dcc.Input(id='nearby', type='number', value=50 ,step=1, className="form-control"),                            
                            html.Br(),
                            html.Br(),
                            html.Br(),
                            html.H4("Timing"),
                            dbc.Label("Start Time:"),
                            html.Br(),
                            html.Div([
                                html.Div([
                                    html.Label("Hours"),
                                    dcc.Input(id='input-hours', type='number', min=0, step=1, value=0, className="form-control"),
                                ], style={'display': 'inline-block', 'margin-right': '10px'}),
                                html.Div([
                                    html.Label("Minutes"),
                                    dcc.Input(id='input-minutes', type='number', min=0, max=59, step=1, value=0, className="form-control"),
                                ], style={'display': 'inline-block', 'margin-right': '10px'}),
                                html.Div([
                                    html.Label("Seconds"),
                                    dcc.Input(id='input-seconds', type='number', min=0, max=59, step=1, value=0, className="form-control"),
                                ], style={'display': 'inline-block'}),
                            ]),
                            html.Br(),
                            dbc.Label("End Time:"),
                            html.Br(),
                            html.Div([
                                html.Div([
                                    html.Label("Hours"),
                                    dcc.Input(id='input-hours_end', type='number', min=0, step=1, value=0, className="form-control"),
                                ], style={'display': 'inline-block', 'margin-right': '10px'}),
                                html.Div([
                                    html.Label("Minutes"),
                                    dcc.Input(id='input-minutes_end', type='number', min=0, max=59, step=1, value=0, className="form-control"),
                                ], style={'display': 'inline-block', 'margin-right': '10px'}),
                                html.Div([
                                    html.Label("Seconds"),
                                    dcc.Input(id='input-seconds_end', type='number', min=0, max=59, step=1, value=0, className="form-control"),
                                ], style={'display': 'inline-block'}),
                            ]),
                            html.Br(),
                        html.Div([
                            html.Label("Cut Duration:", style={'fontWeight': 'bold', 'marginRight': '10px'}),
                            dcc.Input(id='output-duration', disabled=True, style={'width': '100px', 'fontWeight': 'bold'}),
                            dcc.Checklist(
                                options=[{'label': '  Full', 'value': 'on'}],
                                value=[], 
                                id='checkbox',
                                style={'marginLeft': '20px', 'marginTop': '-10px'}) 
                        ], style={'display': 'flex', 'alignItems': 'center', 'marginBottom': '10px'}),

                        html.Div([
                            html.Label("Full Video Duration:", style={'fontWeight': 'bold', 'marginRight': '10px'}),
                            dcc.Input(id='og_duration', disabled=False, style={'width': '100px', 'fontWeight': 'bold'}),
                            
                        ], style={'display': 'flex', 'alignItems': 'center', 'marginBottom': '10px'}),
                            html.Div(id="dur_error", style={"color": "red"}),
                        html.Div([
                            html.Label("Full Video Size:", style={'fontWeight': 'bold', 'marginRight': '10px'}),
                            dcc.Input(id='og_size', disabled=True, style={'width': '100px', 'fontWeight': 'bold'}),
                            
                        ], style={'display': 'flex', 'alignItems': 'center', 'marginBottom': '10px'}),
                        ], width=2),
                        dbc.Col([dbc.Button("Save for later", id="save_later", color="success", n_clicks=0,style=save_link_btn),
                        dbc.Button("Link Check", id="link_check", color="success", n_clicks=0,style=link_check),
                        dbc.Button("Check", id="place_map", color="success", n_clicks=0,style=place_map_btn),
                        dbc.Button("Similar Locations?", id="f_loc", color="success", n_clicks=0,style=check_location)
 # Increase value to push it further down
                    ],width=1),
                        dbc.Col([
                            html.H4("Anchoring Features"),
                            dbc.Label("Distance from a building:"),
                            dcc.Dropdown(
                                id='distance',
                                options=[{'label': d, 'value': d} for d in cleaned_distance],
                                value='',
                                placeholder = "Select a distance",
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Occlusion:"),
                            dcc.Dropdown(
                                id='occlusion_list',
                                options=[{'label': d, 'value': d} for d in cleaned_occlusion],
                                value='',
                                placeholder = "Select an occlusion",
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Terrain type:"),
                            dcc.Dropdown(
                                id='terrain',
                                options=[{'label': d, 'value': d} for d in terrain_list],
                                value="",
                                placeholder = "Select a terrain",
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Logos and text:"),
                            dcc.Dropdown(
                                id='logos_list',
                                options=[{'label': d, 'value': d} for d in cleaned_logos],
                                value='',
                                placeholder = "Select Logos & Text",
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Distortions:"),
                            dcc.Dropdown(
                                id='distortions_list',
                                options=[{'label': d, 'value': d} for d in cleaned_distortions],
                                value='',
                                placeholder = "Select a Distortion",
                                className="form-control"
                            ),
                            html.Br(),
                            html.Br(),
                            html.Br(),
                            html.Br(),                            
                            html.H4(children=f"Map",style=heading_style2),
                            dl.Map(
                                id='map',
                                children=[
                                    dl.TileLayer(),
                                    dl.LayerGroup(id="map-layer", children=[]),
                                    dl.LayerGroup(id="polygon-layer", children=[]),
                                ],
                                center=(41.9028, 12.4964),  
                                zoom=6,
                                style={"width": "100%", "height": "400px", "margin": "6px","border": "2px solid black"}
                            ),
                        ], width=2),
                        dbc.Col(width=1),
                        dbc.Col([
                            html.H4("General Features"),
                            dbc.Label("Time of the day:"),
                            dcc.Dropdown(
                                id='tod',
                                options=[{'label': d, 'value': d} for d in time_list],
                                value='',
                                placeholder = "Select time of day",
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Weather:"),
                            dcc.Dropdown(
                                id='weather',
                                options=[{'label': d, 'value': d} for d in weather_list],
                                value="",
                                placeholder = "Select weather",
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Scene Description:"),
                            dcc.Dropdown(
                                id='scene_desc',
                                options=[{'label': d, 'value': d} for d in scene_description],
                                value="",
                                placeholder = "Pick Scene",
                                multi=False,
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Video Quality:"),
                            dcc.Dropdown(
                                id='vq',
                                options=[{'label': d, 'value': d} for d in cleaned_vq],
                                value="",
                                placeholder = "Select video quality",
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Camera Tilt:"),
                            dcc.Dropdown(
                                id='tilt',
                                options=[{'label': d, 'value': d} for d in cleaned_tilt],
                                value='',
                                placeholder = "Select camera tilt",
                                className="form-control"
                            ),
                            html.Br(),
                            html.Br(),
                            html.Br(),
                            html.H4("Analyst Data"),
                            dbc.Label("Anlyst:"),
                            dcc.Dropdown(
                                id='analysts',
                                options=[{'label': k, 'value': k} for k in analysts],
                                placeholder="Select Analyst",
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Comments:"),
                            dcc.Input(id='comments', type='text', value="", className="form-control"),
                            ],width=2),
                            dbc.Col(width=1),
                        dbc.Col([
                            html.H4("Links Collection",style=heading_style2),
                            dash_table.DataTable(
                                id='links_table',
                                columns=[
                                    {'name': 'Links', 'id': 'links'}, 
                                ],
                                data=[], 
                                row_selectable='single',
                                sort_action="native",
                                filter_action="native",
                                fixed_rows={'headers': True},
                                style_table={
                                    'maxHeight': '250px',
                                    'overflowX': 'auto',
                                    'overflowY': 'auto'
                                },
                                style_cell={
                                    'textAlign': 'center',
                                    'whiteSpace': 'normal',
                                    'overflow': 'hidden',
                                    'textOverflow': 'clip',
                                    'height': 'auto',
                                    'width': '100px',
                                    'maxWidth': '150px',
                                },

                                style_header={
                                    'backgroundColor': 'rgb(30, 30, 30)',
                                    'color': 'white',
                                    'fontWeight': 'bold',
                                },
                            ),
                    html.Br(),
                    html.Br(),    
                    html.Br(),    
                        html.H4("Watch It Here:",style=heading_style2),
                    html.Br(),                 
                html.Div(
                    dash_player.DashPlayer(
                        id='picked_video_insert',
                        url="",
                        controls=True,
                        width="800px",
                        height="400px",
                        style={"border": "2px solid black"}
                    ),
                    style={
                        "display": "flex",
                        "justifyContent": "center",
                        "marginBottom": "-50px",
                    })

                    ],width=3),
                        
                        # Third Column (Button + Modal)
                        dbc.Col([
                            dbc.Button(
                                "Insert",
                                id='insert',
                                color='success',
                                n_clicks=0,
                                style=button_style1
                            ),
                            dbc.Modal(
                                [
                                    dbc.ModalHeader("Video Details"),
                                    dbc.ModalBody(
                                        html.Div(id="confirmation-message", style=modal_style)
                                    ),
                                ],
                                id="confirmation-modal",
                                is_open=False,
                            ),
                            dbc.Modal(
                                [
                                    dbc.ModalHeader("ChatGPT Results"),
                                    dbc.ModalBody(
                                        html.Div(id="gpt_res", style=modal_style)
                                    ),
                                ],
                                id="gpt_modal",
                                is_open=False,
                            ),
                        ], width=2),
                    ])
                ]
            ),
        ]
    )


app.clientside_callback(
    """
    function(n, guard) {
        // Do nothing on page load
        if (!n) { return [window.dash_clientside.no_update,
                          guard || {pending:false, cooldown_until:0},
                          false]; }

        const now = Date.now() / 1000;
        const g = guard || {pending:false, cooldown_until:0};

        // If we're still processing, or still in cool-down, ignore this click
        if (g.pending || (g.cooldown_until && now < g.cooldown_until)) {
            // Keep the button disabled for UX (optional)
            return [window.dash_clientside.no_update, g, true];
        }

        // Accept this click: mark as pending and fire the server via insert_trigger
        return [now, {pending:true, cooldown_until:0}, true];
    }
    """,
    [Output("insert_trigger", "data"),
     Output("insert_guard", "data",allow_duplicate=True),
     Output("insert", "disabled",allow_duplicate=True)],
    [Input("insert", "n_clicks")],
    [State("insert_guard", "data")],
    prevent_initial_call='initial_duplicate'
)



@app.callback(
    Output('upload-image', 'style'),
    Output('output-image-upload', 'style'),
    Output('output-image-upload', 'children'),
    Output('coordinates_input', 'value',allow_duplicate=True),
    Input("insert_type", "value"),
    State('upload-image', 'style'),
    State('output-image-upload', 'style'),
         prevent_initial_call='initial_duplicate'

)
def toggle_visibility(insert_input, upload_state, image_state):
    # Ensure styles are initialized as dictionaries
    if upload_state is None:
        upload_state = {}
    if image_state is None:
        image_state = {}

    if insert_input:
        if insert_input == 'ChatGPT Suggestion':
            upload_state['display'] = 'block'
            image_state['display'] = 'block'

            return upload_state, image_state,html.Div(f""),""
        else:
            upload_state['display'] = 'none'
            image_state['display'] = 'none'
            return upload_state, image_state,html.Div(f""),""
    else:
        upload_state['display'] = 'none'
        return upload_state, dash.no_update,html.Div(f""),""
    
            
            
@app.callback(
    Output('output-image-upload', 'children',allow_duplicate=True),
    Input('upload-image', 'contents'),
    State('upload-image', 'filename'),
     prevent_initial_call='initial_duplicate'

)
def update_output(content, filename):
    if content is not None:
        return html.Div([
            html.H5(filename),
            html.Img(src=content, style={'width': '100%', 'height': 'auto'}),
        ])        


@app.callback(
    Output('coordinates_input', 'value',allow_duplicate=True),
    Output('gpt_modal','is_open'),
    Output('gpt_res','children'),
    Input('upload-image', 'contents'),
    State('cities', 'value'),
    State('upload-image', 'style'),
    
 prevent_initial_call='initial_duplicate'
)
def analyze_image(image_contents, city_name,upload_style):
    if upload_style.get('display') == 'block':
        if not image_contents or not city_name:
            return "Please provide both an image and a city name.",False,""
        else:
            # Extract base64 from content
            try:
                _, encoded = image_contents.split(",", 1)
            except Exception:
                return "Could not read image.",False,""

            prompt = (
                f"Please analyze this image and provide the GPS coordinates "
                f"(latitude and longitude) of the exact location, assuming it is within the city of {city_name}. "
                f"Use high precision — **at least 6–7 decimal places**, like: 44.4493045, 26.086627. "
                f"If the precise location cannot be determined, estimate it based on visible landmarks, signs, or surroundings. "
                f"Return only the coordinates as two decimal values separated by a comma."
            )


            try:
                response = clients.chat.completions.create(
                    model="gpt-4o",
                    messages=[
                        {
                            "role": "user",
                            "content": [
                                {"type": "text", "text": prompt},
                                {
                                    "type": "image_url",
                                    "image_url": {
                                        "url": f"data:image/jpeg;base64,{encoded}"
                                    }
                                }
                            ]
                        }
                    ],
                    max_tokens=1000
)

                content = response.choices[0].message.content
                print("Raw model response:", content)

                # Extract coordinates using regex
                match = re.search(r'(-?\d+\.\d+),\s*(-?\d+\.\d+)', content)
                if match:
                    coords = f"{match.group(1)}, {match.group(2)}"
                    gpt_results = html.Div(f"Raw model response: {content}")
                    return coords,True,gpt_results
                else:
                    gpt_results = html.Div(f"Raw model response: {content}")
                    return "Could not extract coordinates.",True,gpt_results

            except Exception as e:
                return f"Error: {str(e)}",True,f"Failed process file!"
    else:
        return None,False,""

@app.callback(
    Output('poly_store','data'),
    Output('polygon-layer', 'children'),
    

    Input("cities","value"),
)

def poly_extractor(city_val):
    if not city_val:
        return [],[]
    else:
        polygodid = cities[cities['City_Name'] == city_val]['PolygonID'].values[0]
        request = drive_service.files().get_media(fileId=polygodid)
        polygon_bytes = request.execute()

        try:
            if isinstance(polygon_bytes, bytes):
                polygon_data = json.loads(polygon_bytes.decode('utf-8'))
            else:
                polygon_data = json.loads(polygon_bytes)
        except Exception:
            polygon_data = []
        poly_coords = [tuple(coord) for coord in polygon_data]
        poly = Polygon(poly_coords)
        layer =  dl.Polygon(
                        positions=list(poly.exterior.coords),
                        color="blue",
                        fillColor="cyan",
                        fillOpacity=0.6,
                    )
        polygon_layer = dl.LayerGroup(children=layer)
        return poly_coords,polygon_layer
    
    
  
@app.callback(
    Output('output-duration', 'value'),
    [
        Input('input-hours', 'value'),
        Input('input-minutes', 'value'),
        Input('input-seconds', 'value'),
        Input('input-hours_end', 'value'),
        Input('input-minutes_end', 'value'),
        Input('input-seconds_end', 'value'),
        Input('checkbox','value'),
        Input('og_duration', 'value'),
    ]
)


def calculate_duration(start_hours, start_minutes, start_seconds,
                       end_hours, end_minutes, end_seconds, checked,dur_og):
    
    if not checked:
        # Ensure all start and end inputs are valid (not None)
        if start_hours is None or start_minutes is None or start_seconds is None:
            return "Invalid duration!"
        if end_hours is None or end_minutes is None or end_seconds is None:
            return "Invalid duration!"

        # Convert to total seconds
        start_total = start_hours * 3600 + start_minutes * 60 + start_seconds
        end_total = end_hours * 3600 + end_minutes * 60 + end_seconds

        duration_diff = end_total - start_total

        # Handle negative or zero duration
        if duration_diff <= 0:
            return "Invalid duration!"

        hours = duration_diff // 3600
        minutes = (duration_diff % 3600) // 60
        seconds = duration_diff % 60

        return f"{hours:02d}:{minutes:02d}:{seconds:02d}"
    
    else:
        if not dur_og:
            return "Insert full video duration!"
        else:
            parsed_time = datetime.datetime.strptime(dur_og, "%H:%M:%S")
            og_formatted = parsed_time.strftime("%H:%M:%S")

            return og_formatted

@app.callback(
        Output('input-hours', 'value',  allow_duplicate=True),
        Output('input-minutes', 'value',  allow_duplicate=True),
        Output('input-seconds', 'value',  allow_duplicate=True),
        Output('input-hours_end', 'value',  allow_duplicate=True),
        Output('input-minutes_end', 'value',  allow_duplicate=True),
        Output('input-seconds_end', 'value',  allow_duplicate=True),
    [

        Input('checkbox','value'),
        Input('og_duration', 'value'),
    ],
        prevent_initial_call='initial_duplicate'

) 

def re_inputs (checked,full_dur):
    if checked:
        if full_dur:
            sec_start = 0
            min_start = 0
            hh_start = 0
            hours, minutes, seconds = map(int, full_dur.split(":"))
            
            return hh_start,min_start,sec_start,hours, minutes, seconds
        else:
            return (dash.no_update,) * 6
    else:
        sec_start = 0
        min_start = 0
        hh_start = 0
        hours = 0
        minutes = 0
        seconds =0
        
        return hh_start,min_start,sec_start,hours, minutes, seconds

    
    
    
    
@app.callback(
    Output("confirmation-modal",   "is_open",  allow_duplicate=True),
    Output("confirmation-message",   "children",  allow_duplicate=True),
    Input("link_check",         "n_clicks"),           # the ❓ button
    State("link_url",           "value"),              # current URL text
    prevent_initial_call='initial_duplicate'
)
def check_link_exists(n_clicks, link):
    """
    Open a modal warning the user if the entered link is already in the DB.
    """
    if not n_clicks or not link:                       # empty click / URL
        return False, ""                               # close / clear modal

    new_df   = city_load_data(
        "SELECT * FROM `airis-rnd-machines.Sample_Data.Geo_App_DB`"
    )


    filtered_links = new_df[new_df['Links']==link]
    if not filtered_links.empty:                       # 🚫 already exists
        start_list = filtered_links["Start_Time"].tolist()
        end_list = filtered_links["Finish_Time"].tolist()

        msg = html.Div([
            html.P("⚠️ Link already exists with the following timings:"),
            *[
                html.P(f"{i+1}. {start} – {end}")
                for i, (start, end) in enumerate(zip(start_list, end_list))
            ],
            html.P("Please choose a different timing.")
        ])
    else:                                              # ✅ good to go
        msg = "✅ Link does not exist in the DB. Good to go!"

    return True, msg


# ---------------------------------------------------------------------------
# 2️⃣  Metadata extraction  ─────────────────────────────────────────────────
# ---------------------------------------------------------------------------
@app.callback(
    Output("og_duration",            "value"),
    Output("dur_error",           "children"),
    Output("link_title",       "value"),
    Output("link_title",       "disabled"),
    Output("og_size",        "value"),
    Input("link_url",           "value"),
    prevent_initial_call=True,
)
def fetch_link_metadata(link):
    """
    Populate original-duration, title, and size when the URL field changes.
    """
    # URL cleared  ──────────────────────────────────────────────────────────
    if not link:
        return "", "", "", True, ""

    # Fails basic URL validation  ──────────────────────────────────────────
    if not is_valid_url_silent(link):
        return "NA", "Invalid link", "", True, ""

    # Try yt-dlp  ──────────────────────────────────────────────────────────
    try:
        with yt_dlp.YoutubeDL({}) as ydl:
            info = ydl.extract_info(link, download=False)

        secs        = info.get("duration", 0) or 0
        og_dur      = str(datetime.timedelta(seconds=secs))
        video_title = info.get("title", "No title found")
        size_bytes  = info.get("filesize") or info.get("filesize_approx")
        video_size  = f"{size_bytes / (1024 * 1024):.2f} MB" if size_bytes else ""

        return og_dur, "", video_title, True, video_size

    # Any failure in yt-dlp  ────────────────────────────────────────────────
    except Exception:
        return (
            "", "Failed to extract video info. Please insert manually.",
            "Title Not Found! Please insert manually!", False, ""
        )

@app.callback (
    [
        Output('confirmation-modal','is_open',allow_duplicate=True),
        Output('confirmation-message','children',allow_duplicate=True),
    ],
    [
        Input('coordinates_input','value'),
        Input('f_loc','n_clicks'),
        Input('nearby','value'),
        Input("cities","value")
        
    ],
    prevent_initial_call='initial_duplicate'     
) 


def check_famous_locations(f_coordinates, check_button, nearby, city_value):
    import os
    from google.cloud import bigquery
    from dash import html
    from geopy.distance import geodesic  # still used for input validation
    import dash

    ctx = dash.callback_context
    triggered_id = ctx.triggered[0]['prop_id'] if ctx.triggered else None

    if triggered_id == 'f_loc.n_clicks':
        try:
            # Validate incoming coordinates (and normalize to (lat, lon))
            valid_f_coords = valid_coords(f_coordinates)  # your existing validator -> (lat, lon)
            lat, lon = map(float, valid_f_coords.split(","))

            if not nearby or nearby <= 0:
                raise ValueError("Invalid radius value, please make sure it's bigger than 0!")

            # BigQuery client
            bq = bigquery.Client()

            # NOTE: Coordinates column is "lat,lon" as text. We parse in SQL.

            sql = """
                -- Parameters: @city STRING, @lat FLOAT64, @lon FLOAT64, @nearby FLOAT64

                WITH loc AS (
                    SELECT Cut_ID, Coordinates
                    FROM `airis-rnd-machines.Sample_Data.Geo_App_DB`
                    WHERE City = @city
                ),
                cuts AS (
                    SELECT Cut_ID, GCP_Bucket_URL
                    FROM `airis-rnd-machines.Sample_Data.Cuts_DB`
                ),
                geo AS (
                    SELECT
                        l.Cut_ID,
                        c.GCP_Bucket_URL,
                        -- CORRECTION: Use ST_GEOGFROMTEXT to parse the WKT string.
                        ST_GEOGFROMTEXT(
                            CONCAT('POINT(',
                                -- Extract and trim longitude (the second part)
                                TRIM(SPLIT(l.Coordinates, ',')[SAFE_OFFSET(1)]),
                                ' ',
                                -- Extract and trim latitude (the first part)
                                TRIM(SPLIT(l.Coordinates, ',')[SAFE_OFFSET(0)]),
                            ')')
                        ) AS geog
                    FROM loc l
                    LEFT JOIN cuts c USING (Cut_ID)
                ),
                distances AS (
                    SELECT
                        Cut_ID,
                        GCP_Bucket_URL,
                        ST_Y(geog) AS lat,
                        ST_X(geog) AS lon,
                        ST_Distance(geog, ST_GeogPoint(@lon, @lat)) AS distance_m
                    FROM geo
                    WHERE geog IS NOT NULL
                )
                SELECT
                    Cut_ID,
                    GCP_Bucket_URL,
                    lat,
                    lon,
                    distance_m
                FROM distances
                WHERE distance_m <= @nearby
                ORDER BY distance_m ASC;
            """

            job_config = bigquery.QueryJobConfig(
                query_parameters=[
                    bigquery.ScalarQueryParameter("city", "STRING", city_value),
                    bigquery.ScalarQueryParameter("lat", "FLOAT64", lat),
                    bigquery.ScalarQueryParameter("lon", "FLOAT64", lon),
                    bigquery.ScalarQueryParameter("nearby", "FLOAT64", float(nearby)),
                ]
            )
            
            print(lat,lon,nearby)

            results = list(bq.query(sql, job_config=job_config))

            coordinates_num = len(results)
            if coordinates_num == 0:
                found_message = f'No coordinates found within {nearby} meters from {valid_f_coords}!'
            else:
                found_message = html.Div([
                    html.P(
                        f"✅ There are {coordinates_num} coordinate annotations within {nearby} meters "
                        f"around {valid_f_coords} in the following videos:"
                    ),
                    *[
                        html.P(children=[
                            f"{i+1}. ",
                            html.A(
                                href=row["GCP_Bucket_URL"],
                                children=os.path.basename(str(row["GCP_Bucket_URL"]).split("?")[0]),
                                target="_blank"
                            ),
                            f"  — {round(row['distance_m'], 1)} m"
                        ])
                        for i, row in enumerate(results)
                    ]
                ])

            return True, found_message

        except ValueError as e:
            error_message = html.Div(
                [
                    html.H5("⚠️ Validation Error", style={"color": "red"}),
                    html.P(str(e), style={"color": "black"})
                ]
            )
            return True, error_message
        except Exception as e:
            error_message = html.Div(
                [
                    html.H5("🚨 Unexpected Error", style={"color": "red"}),
                    html.P(str(e), style={"color": "black"})
                ]
            )
            return True, error_message
    else:
        return dash.no_update, dash.no_update


@app.callback(
    Output('scene_desc', 'multi'),
    Output('scene_desc', 'value',allow_duplicate=True),
    Input('scene_desc', 'value'),
    prevent_initial_call='initial_duplicate'     

)
def toggle_multi(value):
    if "None" in value:
        multi_val = False
        value = "None"
    else:
        multi_val = True
        value = value
    return multi_val,value
   
@app.callback (
    [
        Output('confirmation-modal','is_open'),
        Output('confirmation-message','children'),
        Output("country","value"),
        Output('link_url','value'),
        Output('coordinates_input','value'),
        Output('sources','value'),
        Output('input-hours','value'),
        Output('input-minutes','value'),
        Output('input-seconds','value'),
        Output('input-hours_end','value'),
        Output('input-minutes_end','value'),
        Output('input-seconds_end','value'), 
        Output('tod','value'),
        Output('weather','value'),       
        Output('vq','value'),    
        Output('tilt','value'),     
        Output('distance','value'),     
        Output('occlusion_list','value'), 
        Output('terrain','value'),   
        Output('logos_list','value'),
        Output('distortions_list','value'),
        Output('analysts','value'),
        Output('comments','value'), 
        Output('links_table','data'),
        Output('links_table_store','data'),
        Output('map', 'viewport'),
        Output('map-layer', 'children'),
        Output('checkbox','value'),
        Output('picked_video_insert','url'),
        Output('link_url_error', 'children'),
        Output('coords_error', 'children'),
        Output("insert", "disabled"),          # re-enable after we finish
        Output("insert_guard", "data"),
        Output('gen_loc','value'),
        Output('scene_desc','value'), 
   
          

],
    
    [
    Input('insert_trigger','data'),
    Input("cities","value"),
    Input('cities', 'options'),
    Input("country","value"),
    Input('link_url','value'),
    Input('coordinates_input','value'),
    Input('sources','value'),
    Input('input-hours','value'),
    Input('input-minutes','value'),
    Input('input-seconds','value'),
    Input('input-hours_end','value'),
    Input('input-minutes_end','value'),
    Input('input-seconds_end','value'), 
    Input('tod','value'),
    Input('weather','value'),       
    Input('vq','value'),    
    Input('tilt','value'),     
    Input('distance','value'),     
    Input('occlusion_list','value'), 
    Input('terrain','value'),   
    Input('logos_list','value'),
    Input('distortions_list','value'),  
    Input('analysts','value'),
    Input('comments','value'), 
    Input('save_later','n_clicks'),
    Input('links_table','selected_rows'),
    Input('place_map','n_clicks'),
    Input('scene_desc','value'),
    Input('map-layer', 'children')

  
         
             
],
[

    State('default-values','data'),
    State('output-duration','value'),
    State('links_table_store','data'),
    State('checkbox','value'),
    State('og_duration', 'value'),
    State("link_title","value"),
    State("og_size","value"),
    State('poly_store','data'),
    State("insert_guard", "data"),
],
prevent_initial_call=True,

)

def validations(insertbtn, city_name,city_options,country_name, linkurl, coords_input,sources,hourst,minst,secst,
                hourend,minend,secend,tod,weather,vq,tilt,distancebuild,occlusion,terrain,logos,distortions,
                analyst,comments,save_later_btn,selected_link,place_on_map,scene_desc, marker_map,
                defaults,dur_input,links_table,checkbox,og_dur,title_vid,og_size_val,poly_tupple,insert_guard):
    ctx = dash.callback_context
    triggered_id = ctx.triggered[0]['prop_id'] if ctx.triggered else None
    
    

    if links_table is not None and (
            (isinstance(links_table, pd.DataFrame) and not links_table.empty)  # DataFrame
            or (not isinstance(links_table, pd.DataFrame) and len(links_table))  # list / dict-list
    ):
        links_data = links_table
    else:
        links_data = []
        
        
    if triggered_id == 'link_url.value':
        if linkurl:
            try:                      
                valid_url_watch = is_valid_url(linkurl)
                if valid_url_watch:
                    picked_video = valid_url_watch
                    return (
                        dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                        dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                        dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                        dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                        dash.no_update, dash.no_update, dash.no_update,dash.no_update,picked_video,"",dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update   
                    )
            except ValueError as e:
                # If any validation fails, catch and show the error message
                error_input = html.Div(f"Incorrect Link Format", style={"color": "red"})

                return(False, "",dash.no_update,dash.no_update,dash.no_update,dash.no_update,
                dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,
                dash.no_update,dash.no_update,dash.no_update, dash.no_update,dash.no_update,dash.no_update,
                dash.no_update,dash.no_update, dash.no_update,dash.no_update,dash.no_update, dash.no_update , dash.no_update,    
                dash.no_update , dash.no_update,dash.no_update,dash.no_update,error_input,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update   )
        else:
            return (
            dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
            dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
            dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
            dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
            dash.no_update, dash.no_update, dash.no_update,dash.no_update,"","",dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update   
        )   
    if triggered_id == 'coordinates_input.value':
        if coords_input:
            try: 
                valid_coordintes_place = is_valid_coord(coords_input)
                if valid_coordintes_place or coords_input:
                    lat, lon = map(float, coords_input.split(","))
                    marker = dl.Marker(
                        position=[lat, lon],
                        children=[dl.Popup(coords_input)],
                        id='city-mark'
                    )

                    viewport = {'center': [lat, lon], 'zoom': 14} 
                    
                    from geopy.geocoders import Nominatim
                    geolocator = Nominatim(user_agent="my_geo_app_roy")
                    location = geolocator.reverse((coords_input))
                    
                    if not location:
                        location_output = "Location Was Not Found!"
                    else:
                        location_output = location.address                                     
                    return (
                        dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                        dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                        dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                        dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                        dash.no_update, viewport, [marker],dash.no_update,dash.no_update,dash.no_update,"",dash.no_update,dash.no_update,location_output,dash.no_update  
                    )
            except ValueError as e:
                # If any validation fails, catch and show the error message
                error_input = html.Div(f"Incorrect Coordinates Format", style={"color": "red"})
                
                return(dash.no_update, dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,
                dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,
                dash.no_update,dash.no_update,dash.no_update, dash.no_update,dash.no_update,dash.no_update,
                dash.no_update,dash.no_update, dash.no_update,dash.no_update,dash.no_update, dash.no_update , dash.no_update,    
                dash.no_update , dash.no_update,dash.no_update,dash.no_update,dash.no_update,error_input,dash.no_update,dash.no_update,"",dash.no_update )
        else:
            if city_name:
                center= cities[cities['City_Name'] == city_name]['CityCenter'].iloc[0]
                lat, lon =map(float, center.split(",")) 
                map_center_city = {'center': [lat, lon], 'zoom': 10}
            else:
                map_center_city = {'center': [41.9028, 12.4964], 'zoom': 10}    
            return (
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, map_center_city,[],dash.no_update,dash.no_update,dash.no_update,"",dash.no_update,dash.no_update,"",dash.no_update  
            ) 


                    
    elif triggered_id == 'insert_trigger.data':

        try:

            from datetime import datetime
            import pytz

            if not insert_guard or not insert_guard.get("pending"):
                raise PreventUpdate 
                       
            general_validation = general_validations (analyst,city_name,distancebuild,title_vid,occlusion,terrain,logos,
                         distortions, tod,weather,vq,tilt,sources,scene_desc)
        
            

               
            valid_url = is_valid_url(linkurl)                
            valid_coordinates = valid_coords(coords_input)

            lat, lon = map(float, valid_coordinates.split(","))    

            if not is_inside_any(lat, lon, poly_tupple): 
                raise ValueError ("Make sure you're coordinates are in the polygon!") 
            
            df_all =city_load_data("SELECT * FROM `airis-rnd-machines.Sample_Data.Geo_App_DB`")
            cut_db = city_load_data("SELECT * FROM `airis-rnd-machines.Sample_Data.Cuts_DB`")
            
            matched_rows = df_all[df_all['Links'] == valid_url]
            
            if checkbox is None or len(checkbox) == 0:    
                start_time = f"{hourst:02}:{minst:02}:{secst:02}"
                end_time = f"{hourend:02}:{minend:02}:{secend:02}"
                h, m, s = map(int, dur_input.split(":"))
                dur_time =   f"{h:02}:{m:02}:{s:02}"
            else: 
                start_time = f"{hourst:02}:{minst:02}:{secst:02}"
                end_time = f"{hourend:02}:{minend:02}:{secend:02}"         
                dur_time = dur_input  
               
            time_obj = datetime.strptime(dur_time, "%H:%M:%S")
            dur_parse = time_obj.hour * 3600 + time_obj.minute * 60 + time_obj.second
            
            if dur_parse > 300:
                raise ValueError("Pay Attention! Cut duration exceeding 5 minutes!")
            # Step 2: If there are any such rows, check for coordinate match
            if not matched_rows.empty:
                match_copy = matched_rows.copy()
                match_copy['base'] = match_copy['Cut_ID'].str.extract(r'^(.*)_v\d+$')[0] 
                match_copy['version'] = match_copy['Cut_ID'].str.extract(r'_v(\d+)$')[0].astype(int)
                
                # Step 3: Keep only the latest version for each base
                latest_versions = match_copy.sort_values('version').groupby('base', as_index=False).last()                
                if valid_coordinates in latest_versions['Coordinates'].values:
                    raise ValueError("Video link and Coordinates already exist!")  

                video_name = match_copy['Title'].values[0]
                video_og_dur = match_copy['Original_Duration'].values[0]


                match_rows = latest_versions.copy()  # Safely modify

                time_to_check = parse_time(start_time)
                match_rows['Start Time Parsed'] = match_rows['Start_Time'].apply(parse_time)
                match_rows['Finish Time Parsed'] = match_rows['Finish_Time'].apply(parse_time)

                dur_dup = match_rows.apply(
                    lambda row: row['Start Time Parsed'] <= time_to_check <= row['Finish Time Parsed'],
                    axis=1
                )

                full_video_cross = match_rows.apply(
                    lambda row: row['Duration'] == "Full Video" ,
                    axis=1
                )

                if dur_dup.any() or full_video_cross.any():
                    raise ValueError("There's already this video with another crossing timing, please select another duration!")


            else:   
                if 'youtube' in valid_url and 'Youtube' in sources:
                    with yt_dlp.YoutubeDL() as ydl:
                        video_name = title_vid
                       

                elif 'tiktok' in valid_url and 'Tiktok' in sources:
                    with yt_dlp.YoutubeDL() as ydl:

                        video_name = title_vid

                elif 'facebook' in valid_url and 'facebook' in sources:
                    with yt_dlp.YoutubeDL() as ydl:
                        video_name = title_vid
                        
                else:
                    raise ValueError("Video title not found - maybe not a matching source?")
                

            end_time_check = parse_input_time(end_time)
            og_dur_check = parse_duration(og_dur)
            
            if end_time_check > og_dur_check:
                raise ValueError ("Annotation time exceeding original video duration!")




            local_tz = pytz.timezone("Asia/Jerusalem")
            local_dt = datetime.now(local_tz)  # already in GMT+3 if DST applies
            formatted_datetime = local_dt.strftime("%Y-%m-%d %H:%M:%S")
    
           
            cut_id = generate_unique_random_id(city_name,df_all,valid_url)
            video_id = '_'.join(cut_id.split('_')[:3])

            if og_dur:
                parts = og_dur.split(":")
                if parts[0] == "0":
                    # Pad the time string to ensure it has three parts
                    time_parts = list(map(int, parts[1:]))
                    if len(time_parts) == 2:
                        hours = 0
                        minutes, seconds = time_parts
                    elif len(time_parts) == 1:
                        hours = 0
                        minutes = 0
                        seconds = time_parts[0]
                    else:
                        raise ValueError("Invalid duration format")
                    formatted_dur = f"{hours:02}:{minutes:02}:{seconds:02d}"
                else:
                    formatted_dur = og_dur     
            else:
                raise ValueError("Please insert original video duration")
   
            
            latest_index = int(df_all['Index'].max()) + 1

            time_stamp = formatted_datetime
            
            row_data =[latest_index,cut_id,video_id,country_name,city_name,linkurl,video_name,valid_coordinates,analyst,sources,formatted_dur,start_time,end_time,dur_time,
                       tod,terrain,weather,vq,tilt,distancebuild,occlusion,distortions,
                       logos,comments,formatted_datetime,scene_desc]
            print(row_data)
            append_row_to_bq(row_data,table_id="airis-rnd-machines.Sample_Data.Geo_App_DB")
            

            
            latest_cut_index = int(cut_db['Index'].max()) + 1
            cuts_row_data =[latest_cut_index,cut_id,country_name,city_name,linkurl,video_name,'TBD',start_time,end_time,dur_time,'TBD',
                            'TBD','FALSE','og_user',None,og_size_val,formatted_dur]
            
            print(cuts_row_data)
            append_row_to_bq(cuts_row_data, table_id="airis-rnd-machines.Sample_Data.Cuts_DB")
            
            
            lat, lon = map(float, valid_coordinates.split(","))   
            marker = dl.Marker(
                position=[lat, lon],
                children=[dl.Popup(valid_coordinates)],
                id='city-mark'
            )

            viewport = {'center': [lat, lon], 'zoom': 10}
            
            links_dframe = pd.DataFrame(links_table or [])

            links_dframe = pd.DataFrame(links_table or [])
            if 'links' in links_dframe.columns:
                links_dframe = links_dframe[links_dframe['links'] != valid_url]
            else:
                links_dframe = pd.DataFrame(columns=['links'])
            links_data_clean = links_dframe.to_dict('records')

            import time

            now = time.time()
            guard_after_success = {"pending": False, "cooldown_until": now + 25}
                                                   
            # If all validations pass
            result_window = html.Div([
                html.H1('Video Added Successfully!'),
                html.Br(),
                html.H3("Video Details: "),
                html.Ul([
                    html.Li(f"City: {city_name}"),
                    html.Li(f"City: {country_name}"),
                    html.Li(f"Cut_id: {cut_id}"),
                    html.Li(f"Video Link: {valid_url}"),
                    html.Li(f"Video Name: {video_name}"),
                    html.Li(f"Video Source: {sources}"),                    
                    html.Li(f"Coordinates: {valid_coordinates}"),
                    html.Li(f"Start Time: {start_time}"),
                    html.Li(f"Finish Time: {end_time}"),                    
                    html.Li(f"Video Duration: {dur_time}"),
                    html.Li(f"Analyst: {analyst}"),
                    html.Li(f"Time of the day: {tod}"),
                    html.Li(f"Weather: {weather}"), 
                    html.Li(f"Scene Description: {scene_desc}"),
                    html.Li(f"Video Quality: {vq}"), 
                    html.Li(f"Camera Tilt: {tilt}"),
                    html.Li(f"Distance from a building: {distancebuild}"),
                    html.Li(f"Occlusion: {occlusion}"),                                         
                    html.Li(f"Terrain: {terrain}"),
                    html.Li(f"Logos and Text: {logos}"),
                    html.Li(f"Distortions: {distortions}"),
                    html.Li(f"Comments: {comments}")                                                                    
                ])
            ])
            
            
            return (True, result_window,
            dash.no_update,
            defaults['link_url'],
            defaults['coordinates_input'],
            defaults['sources'],
            defaults['input-hours'],
            defaults['input-minutes'],
            defaults['input-seconds'],
            defaults['input-hours_end'],
            defaults['input-minutes_end'],
            defaults['input-seconds_end'],
            defaults['tod'],
            defaults['weather'],
            defaults['vq'],  
            defaults['tilt'],
            defaults['distance'],
            defaults['occlusion_list'],     
            defaults['terrain'],
            defaults['logos_list'],
            defaults['distortions_list'],
            defaults['analysts'],  
            defaults['comments'], links_data_clean , links_data_clean, viewport, [],[],"",dash.no_update,dash.no_update ,False,guard_after_success,"",defaults['scene_desc']                      
            )


        except ValueError as e:
            # If any validation fails, catch and show the error message
            error_message = html.Div(
                [
                    html.H5("⚠️ Validation Error", style={"color": "red"}),
                    html.P(str(e), style={"color": "black"})
                ]
            )
            
            guard_after_fail = {"pending": False, "cooldown_until": (insert_guard or {}).get("cooldown_until", 0)}

            return( True, error_message,dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update, dash.no_update , dash.no_update, dash.no_update ,
            dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,False,guard_after_fail,dash.no_update,dash.no_update  )
    
    elif triggered_id == 'save_later.n_clicks':
        try:
            valid_url = is_valid_url(linkurl)
            if valid_url:
                if links_table is not None:

                    links_entry = next((entry for entry in links_table if entry.get('links') == valid_url), None) 
                    if links_entry is None:
                        row_links_table = {
                        "links": f"{valid_url}"}
                        links_data.append(row_links_table)
                    else:
                        links_data = links_table
                else:
                    row_links_table = {
                    "links": f"{valid_url}"}
                    links_data.append(row_links_table)
            
            return (False,dash.no_update,dash.no_update,"",dash.no_update,dash.no_update,dash.no_update,dash.no_update,
            dash.no_update, dash.no_update,dash.no_update, dash.no_update,dash.no_update,dash.no_update,dash.no_update,
            dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,
            dash.no_update, links_data ,links_data, dash.no_update , dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update   )
            
        except ValueError as e:
            # If any validation fails, catch and show the error message
            error_message = html.Div(
                [
                    html.H5("⚠️ Validation Error", style={"color": "red"}),
                    html.P(str(e), style={"color": "black"})
                ]
            )
        return( True, error_message,dash.no_update,dash.no_update,dash.no_update,dash.no_update,
        dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,
        dash.no_update,dash.no_update,dash.no_update, dash.no_update,dash.no_update,dash.no_update,
        dash.no_update,dash.no_update, dash.no_update,dash.no_update,dash.no_update, dash.no_update , dash.no_update,    
         dash.no_update , dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update   )
        
    elif triggered_id == 'links_table.selected_rows':
        row_idx = selected_link[0]
        links_df = pd.DataFrame(links_table)
        if row_idx < len(links_df):
            selected_url = links_df.iloc[row_idx][links_df.columns[0]]
            picked_url = selected_url
        return (False,dash.no_update,dash.no_update,selected_url,dash.no_update,dash.no_update,dash.no_update,dash.no_update,
        dash.no_update, dash.no_update,dash.no_update, dash.no_update,dash.no_update,dash.no_update,dash.no_update,
        dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,
        dash.no_update, dash.no_update ,dash.no_update, dash.no_update , dash.no_update,dash.no_update,picked_url,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update   )
    
    
    elif triggered_id == 'place_map.n_clicks':
        try:
            validated_coor = valid_coords(coords_input)
            if not validated_coor or not city_name:
                raise ValueError('Please insert both coordinates & city name!')
            
            lat, lon = map(float, validated_coor.split(","))    

            if is_inside_any(lat, lon, poly_tupple):
                validation_msg = html.Div(
                    [
                        html.H5("✅ Success", style={"color": "green"}),
                        html.P(f"{validated_coor} is in the Polygon", style={"color": "green", "font-weight": "bold"})
                    ]
                )
            else:
                validation_msg = html.Div(
                    [
                        html.H5("❌ Warning", style={"color": "red"}),
                        html.P(f"{validated_coor} is out of the Polygon", style={"color": "red", "font-weight": "bold"})
                    ]
                )

            marker = dl.Marker(
                position=[lat, lon],
                children=[dl.Popup(validated_coor)],
                id='city-mark'
            )

            viewport = {'center': [lat, lon], 'zoom': 10}



            return (
                True, validation_msg, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update,
                viewport, [marker],dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update   )

        except ValueError as e:
            error_message = html.Div(
                [
                    html.H5("⚠️ Validation Error", style={"color": "red"}),
                    html.P(str(e), style={"color": "black"})
                ]
            )

            return (
                True, error_message, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update   
            )


        
                                                     
    else:
        # Update Country based on City selected
        if triggered_id == 'cities.value':
            if city_name:
                country_match = cities[cities['City_Name'] == city_name]['Country']
                country_val = country_match.iloc[0] if not country_match.empty else ''
                center= cities[cities['City_Name'] == city_name]['CityCenter'].iloc[0]
                lat, lon =map(float, center.split(",")) 
                map_center_city = {'center': [lat, lon], 'zoom': 10}         
            else:
                country_val = ''
                map_center_city= {'center': [41.9028, 12.4964], 'zoom': 10} 
            return (False,dash.no_update,country_val,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, map_center_city,
                [],dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update   )  # Rest of outputs unchanged
        else:

            return (False, dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update,
                    dash.no_update, dash.no_update, dash.no_update, dash.no_update ,
                    dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update   )

filters_list= ['City','Record ID','Analyst']        

# Find the first timestamp
df_city_edit['TimeStamp'] = pd.to_datetime(df_city_edit['TimeStamp'], errors='coerce')

# 2. Drop rows with bad timestamps if needed
df_city_edit = df_city_edit.dropna(subset=['TimeStamp'])

# 3. Get the earliest timestamp
first_timestamp = df_city_edit['TimeStamp'].min()


timeframes = ["", "Year", "1/2 Year", "3 Months", "Month", "Week", "Day", ""]

def edit_tab_layout():
     return html.Div(
        style=background_style,
        children=[
            dbc.Container(
                style=container_style_2,
                children=[
                dcc.Store(id='default-values_edit', data={
                    'link_url_edit': "",
                    "coordinates_input_edit": "",
                    'sources_edit': "",
                    'input-hours_edit': 0,
                    'input-minutes_edit': 0,
                    'input-seconds_edit': 0,
                    'input-hours_end_edit': 0,
                    'input-minutes_end_edit': 0,
                    'input-seconds_end_edit': 0,
                    'tod_edit': '',
                    'weather_edit': "",
                    'vq_edit': "",
                    'tilt_edit': '',
                    'distance_edit': '',
                    'occlusion_list_edit': '',
                    'terrain_edit': "",
                    'logos_list_edit': '',
                    'distortions_list_edit': '',
                    'analysts_edit': 'Select Analyst',
                    'comments_edit':""
                }),
                dcc.Store(id="stored-videoid", data=None),
                dcc.Store(id='latest_df',data=None),
                dcc.Store(id='latest_cut',data=None),

                    html.H1("Edit Mode", style=heading_style),
                    html.Hr(),

                    dbc.Row([
                        # First Column
                        dbc.Col([
                            html.H4("Pick a City & Video"),
                            dbc.Label("Choose a Filter:"),
                            dcc.Dropdown(
                                id='filters_list',
                                options=[{'label': k, 'value': k} for k in filters_list],
                                value="",
                                className="form-control",
                                placeholder = "Select a filter"
                            ),   
                            html.Br(),
                            dbc.Label("Filter Annotation Time by Last (All Time - Hour):"),
                            html.Div(
                                dcc.RangeSlider(
                                    id='timeframe_slider',
                                    min=0,
                                    max=len(timeframes) - 1,
                                    step=1,
                                    value=[0, len(timeframes) - 1],
                                    marks={i: label for i, label in enumerate(timeframes)},
                                    tooltip={"always_visible": True, "placement": "bottom"}
                                ),
                                style={"width": "550px", "margin-bottom": "20px"}  # Increase width as needed
                            ),
                            html.Br(),  
                            html.Br(),                       
                            dbc.Label("Choose a sub filter:"),
                            dcc.Dropdown(
                                id='cities_edit',
                                options=[{'label': k, 'value': k} for k in cities_list],
                                value="",
                                className="form-control"
                            ),
                            html.Br(),
                        html.Div([
                            dbc.Row([
                                dbc.Col([
                                    dbc.Label("Pick a Cut ID:"),
                                    dcc.Dropdown(
                                        id='videoid_edit',
                                        options=[],
                                        value="",
                                        className="form-control",
                                        placeholder="Select a cut id"
                                    )
                                ], width=7),  # Half width
                                dbc.Col([
                                    dbc.Label("Pick a Version:"),
                                    dcc.Dropdown(
                                        id='cut_version',
                                        options=[],
                                        value="",
                                        className="form-control",
                                        placeholder="Select a version"
                                    )
                                ], width=5)  # Half width
                            ]),
                            html.Br()
                        ]),
                            dbc.Label("Pick a source:"),
                            dcc.Dropdown(
                                id='sources_edit',
                                options=[{'label': d, 'value': d} for d in source_list],
                                value="",
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Video Link:"),
                            dcc.Input(id='link_url_edit', type='text', value="", className="form-control"),
                            html.Div(id="link_error_edit", style={"color": "red"}),
                            html.Br(),
                            dbc.Label("Coordinates:"),
                            dcc.Input(id='coordinates_input_edit', type='text', value="", className="form-control"),
                            html.Div(id="coords_error_ed", style={"color": "red"}),
                            html.Br(),
                            html.Br(),
                            html.Br(),
                            html.H4("Timing"),
                            dbc.Label("Start Time:"),
                            html.Br(),
                            html.Div([
                                html.Div([
                                    html.Label("Hours"),
                                    dcc.Input(id='input-hours_edit', type='number', min=0, step=1, value=0, className="form-control"),
                                ], style={'display': 'inline-block', 'margin-right': '10px'}),
                                html.Div([
                                    html.Label("Minutes"),
                                    dcc.Input(id='input-minutes_edit', type='number', min=0, max=59, step=1, value=0, className="form-control"),
                                ], style={'display': 'inline-block', 'margin-right': '10px'}),
                                html.Div([
                                    html.Label("Seconds"),
                                    dcc.Input(id='input-seconds_edit', type='number', min=0, max=59, step=1, value=0, className="form-control"),
                                ], style={'display': 'inline-block'}),
                            ]),
                            html.Br(),
                            dbc.Label("End Time:"),
                            html.Br(),
                            html.Div([
                                html.Div([
                                    html.Label("Hours"),
                                    dcc.Input(id='input-hours_end_edit', type='number', min=0, step=1, value=0, className="form-control"),
                                ], style={'display': 'inline-block', 'margin-right': '10px'}),
                                html.Div([
                                    html.Label("Minutes"),
                                    dcc.Input(id='input-minutes_end_edit', type='number', min=0, max=59, step=1, value=0, className="form-control"),
                                ], style={'display': 'inline-block', 'margin-right': '10px'}),
                                html.Div([
                                    html.Label("Seconds"),
                                    dcc.Input(id='input-seconds_end_edit', type='number', min=0, max=59, step=1, value=0, className="form-control"),
                                ], style={'display': 'inline-block'}),
                            ]),
                            html.Br(),
                            dbc.Label("Duration:  "),
                            dcc.Input(id='output-duration_edit', disabled=True, style={'margin-top': '30px', 'margin-left': '30px','font-weight': 'bold'}),
                            html.Div([
                                html.Label("Full Video Duration:", style={'fontWeight': 'bold', 'marginRight': '10px'}),
                                dcc.Input(id='og_dur_ed', disabled=False, style={'width': '100px', 'fontWeight': 'bold'}),
                                
                            ], style={'display': 'flex', 'alignItems': 'center', 'marginBottom': '10px'}),
                            html.Div([
                                html.Label("Full Video Size:", style={'fontWeight': 'bold', 'marginRight': '10px'}),
                                dcc.Input(id='og_size_ed', disabled=True, style={'width': '100px', 'fontWeight': 'bold'}),
                                
                            ], style={'display': 'flex', 'alignItems': 'center', 'marginBottom': '10px'}),                        

                        ], width=2),
                        dbc.Col([
                            html.Div([dbc.Label("Records Number:"),
                            html.Br(),
                            dcc.Input(id='rec_num', type='number', disabled=True, value=0, className="form-control")]
                            ,style=rec_num),
                            dbc.Button("↻", id='update_ids', color='success', n_clicks=0, style=button_style4),
                            dbc.Button("Check", id="place_map_ed", color="success", n_clicks=0,style=check_btn_ed),
                            dcc.Checklist(
                                    options=[{'label': '  Full', 'value': 'on'}],
                                    value=[], 
                                    id='checkbox_edit',
                                    style={'marginLeft': '-50px', 'marginTop': '965px'})                             
                            ],width=1),
                        dbc.Col([
                            html.H4("Anchoring Features"),
                            dbc.Label("Distance from a building:"),
                            dcc.Dropdown(
                                id='distance_edit',
                                options=[{'label': d, 'value': d} for d in distance],
                                value='',
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Occlusion:"),
                            dcc.Dropdown(
                                id='occlusion_list_edit',
                                options=[{'label': d, 'value': d} for d in occlusion],
                                value='',
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Terrain type:"),
                            dcc.Dropdown(
                                id='terrain_edit',
                                options=[{'label': d, 'value': d} for d in terrain_list],
                                value="",
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Logos and text:"),
                            dcc.Dropdown(
                                id='logos_list_edit',
                                options=[{'label': d, 'value': d} for d in logos],
                                value='',
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Distortions:"),
                            dcc.Dropdown(
                                id='distortions_list_edit',
                                options=[{'label': d, 'value': d} for d in distortions],
                                value='',
                                className="form-control"
                            ),
                            html.Br(),
                            html.Br(),
                            html.Br(),
                            html.Br(),      
                            html.H4("Map",id="map_title",style=heading_style2),
                            dl.Map(
                                id='map_edit',
                                children=[
                                    dl.TileLayer(),
                                    dl.LayerGroup(id="map-layer_ed", children=[]),
                                ],
                                center=(41.9028, 12.4964),  
                                zoom=10,
                                style={"width": "100%", "height": "400px", "margin": "6px","border": "2px solid black"}
                            ),
                        ], width=2),
                        dbc.Col(width=1),
                        dbc.Col([
                            html.H4("General Features"),
                            dbc.Label("Time of the day:"),
                            dcc.Dropdown(
                                id='tod_edit',
                                options=[{'label': d, 'value': d} for d in time_list],
                                value='',
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Weather:"),
                            dcc.Dropdown(
                                id='weather_edit',
                                options=[{'label': d, 'value': d} for d in weather_list],
                                value="",
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Video Quality:"),
                            dcc.Dropdown(
                                id='vq_edit',
                                options=[{'label': d, 'value': d} for d in video_vq],
                                value="",
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Camera Tilt:"),
                            dcc.Dropdown(
                                id='tilt_edit',
                                options=[{'label': d, 'value': d} for d in camera_tilt],
                                value='',
                                className="form-control"
                            ),
                            html.Br(),
                            html.Br(),
                            html.Br(),
                            html.H4("Analyst Data"),
                            dbc.Label("Anlyst:"),
                            dcc.Dropdown(
                                id='analysts_edit',
                                options=[{'label': k, 'value': k} for k in analysts],
                                placeholder="Select Analyst",
                                className="form-control"
                            ),
                            html.Br(),
                            dbc.Label("Comments:"),
                            dcc.Input(id='comments_edit', type='text', value="", className="form-control"),                           
                            ],width=2),
                        dbc.Col([html.H2("Watch It Here:"),
                    html.Br(),
                    html.Br(),    
                    html.Br(),                 
                html.Div(
                    dash_player.DashPlayer(
                        id='picked_video_edit',
                        url="",
                        controls=True,
                        width="800px",
                        height="400px",
                        style={"border": "2px solid black"}
                    ),
                    style={
                        "display": "flex",
                        "justifyContent": "center",
                        "marginBottom": "-50px",
                    }
                ),
                
                html.Div([
                    html.Br(),
                    html.Div([
                        html.H2("To Full Dashboard", style={"textAlign": "center"}),  # added centered H2
                        html.A(
                            html.Img(
                                src="/assets/Full_Dashboard.png",
                                alt="To The Full Dashboard",  # added alt
                                style={
                                    'width': '500px',
                                    'border': '1px solid black'
                                }
                            ),
                            href='http://data-team-dashboard:8000/',
                            target='_blank'  # opens link in new tab
                        )
                    ])
                ],
                style={
                    "display": "flex",
                    "justifyContent": "right",
                    "gap": "70px",
                    "marginTop": "120px"
                })

  
                    ],width=4), 
                    html.Br(),
                    html.Div(
                        [
                            dbc.Button("Update", id='update', color='success', n_clicks=0, style=button_style2),
                            
                        ],
                        style={"display": "flex", "justifyContent": "right", "gap": "40px", "marginBottom": "30px"}
                    ),
                        # Third Column (Button + Modal)

                            dbc.Modal(
                                [
                                    dbc.ModalHeader("Edit Mode:"),
                                    dbc.ModalBody(
                                        html.Div(id="confirmation-message_edit", style=modal_style)
                                    ),
                                ],
                                id="confirmation-modal_edit",
                                is_open=False,
                            ),
                            dbc.Modal(
                                [
                                    dbc.ModalHeader("Confirmation"),
                                    dbc.ModalBody(
                                        html.Div("Are you sure you want to proceed?", style=modal_style)
                                    ),
                                    dbc.ModalFooter(
                                        dbc.ButtonGroup(
                                            [
                                                dbc.Button("Yes", id="confirm-yes", color="success", n_clicks=0),
                                                dbc.Button("No", id="confirm-no", color="danger", n_clicks=0),
                                            ],
                                            className="w-100",  # full width button group
                                        )
                                    ),
                                ],
                                id="confirmation-update",
                                is_open=False,
                            ),
                    dbc.Modal(
                        [
                            dbc.ModalHeader("Removal Confirmation"),
                            dbc.ModalBody([
                                dbc.Label("Since it's a irreversable action, please insert the removal key: "),
                                dbc.Input(
                                    id="delete_password",
                                    type="password",
                                    placeholder="Enter your password...",
                                )
                        ]),
                            dbc.ModalFooter(
                                dbc.Button(
                                    "Delete",
                                    id="delete_btn",
                                    color="primary",
                                    className="ml-auto"
                                ),
                            ),
                        ],
                        id="delete-modal",
                        is_open=False,  # Initially closed
                    ),
                    ])
                ]
            ),
        ]
    )

def video_options_per_time (df,timing):
    today = pd.Timestamp.today().normalize()
    df['TimeStamp'] = pd.to_datetime(df['TimeStamp'], errors='coerce')
    time_delta = today - pd.Timedelta(days=timing)
    mask = df['TimeStamp'].between(time_delta, today)
    filtered_df = df.loc[mask].copy()
    filtered_df['base'] = filtered_df['Cut_iD'].str.extract(r'^(.*)_v\d+$')[0]
    voptions = filtered_df['base'].unique()
    
    return voptions
global time_constants
time_constants = ['Up to a week ago', 'Up to 2 weeks ago','Up to a month ago','Up to 3 months ago','Up to half a year ago', 'Up to a year ago', 'All Time'] 


@app.callback(
    Output('output-duration_edit', 'value'),
    [
        Input('input-hours_edit','value'),
        Input('input-minutes_edit','value'),
        Input('input-seconds_edit','value'),
        Input('input-hours_end_edit','value'),
        Input('input-minutes_end_edit','value'),
        Input('input-seconds_end_edit','value'),
        Input('checkbox_edit','value') 
    ]
)

def calculate_duration_edit(start_hours, start_minutes, start_seconds,
                       end_hours, end_minutes, end_seconds,checkbox_edit):
    # Calculate start and end times in total seconds
    if not checkbox_edit:
        # Ensure all start and end inputs are valid (not None)
        if start_hours is None or start_minutes is None or start_seconds is None:
            return "Invalid duration!"
        if end_hours is None or end_minutes is None or end_seconds is None:
            return "Invalid duration!"

        # Convert to total seconds
        start_total = start_hours * 3600 + start_minutes * 60 + start_seconds
        end_total = end_hours * 3600 + end_minutes * 60 + end_seconds

        duration_diff = end_total - start_total

        # Handle negative or zero duration
        if duration_diff <= 0:
            return "Invalid duration!"

        hours = duration_diff // 3600
        minutes = (duration_diff % 3600) // 60
        seconds = duration_diff % 60

        return f"{hours:02d}:{minutes:02d}:{seconds:02d}"
    
    else:
        return "Full Video"


    
@app.callback(
    Output("cities_edit", "options"),
    Output("cities_edit", "value"),

    Output("latest_df",   "data"),
    Output("latest_cut",   "data"),

    Input("timeframe_slider", "value"),
    Input("filters_list", "value"),
    Input("update_ids",   "n_clicks"),
    
    prevent_initial_call='initial_duplicate'

)
def load_sub_filter(slider_val, selected_filter,update_ids):
    ctx = dash.callback_context
    triggered_id = ctx.triggered[0]['prop_id'] if ctx.triggered else None
    
    df_city_edit = city_load_data("SELECT * FROM `airis-rnd-machines.Sample_Data.Geo_App_DB`")
    # Assume slider_val is a list/tuple like [start_days_ago, end_days_ago]
    low_idx, high_idx = slider_val
    index_to_days = {
        7: 0,      # last hour? or 0 days? adjust as needed
        6: 1,      # last day
        5: 7,      # last week
        4: 30,     # last month
        3: 90,     # last 3 months
        2: 183,    # last 6 months
        1: 365,    # last year
        0: 1000    # "all time" or large number
    }

    now = pd.Timestamp.now(tz="Asia/Jerusalem")

    # map low_idx and high_idx separately
    start_cutoff = now - timedelta(days=index_to_days[high_idx])
    end_cutoff = now - timedelta(days=index_to_days[low_idx])

    df_city_edit['TimeStamp'] = pd.to_datetime(df_city_edit['TimeStamp'], utc=False, errors='coerce')        

    # Ensure timestamps are tz-aware
    if df_city_edit['TimeStamp'].dt.tz is None:
        df_city_edit['TimeStamp'] = df_city_edit['TimeStamp'].dt.tz_localize("Asia/Jerusalem")

    # Ensure start <= end
    if start_cutoff > end_cutoff:
        start_cutoff, end_cutoff = end_cutoff, start_cutoff

    # Filter using BETWEEN start and end
    filtered_df = df_city_edit[
        (df_city_edit['TimeStamp'] >= start_cutoff) &
        (df_city_edit['TimeStamp'] <= end_cutoff)
    ]

    # Return unique values based on selected filter
    if selected_filter == "City":
        opts = sorted(filtered_df["City"].dropna().unique())
    elif selected_filter == "Record ID":
        opts = sorted(filtered_df["record_id"].dropna().unique())
    elif selected_filter == "Analyst":
        opts = sorted(filtered_df["Analyst"].dropna().unique())
    else:
        opts = []
        
    if triggered_id == "update_ids.n_clicks":
        return (opts, "" , df_city_edit.to_dict('records'),city_load_data("SELECT * FROM `airis-rnd-machines.Sample_Data.Cuts_DB`").to_dict('records')) 
    else: 
        return (opts,dash.no_update, df_city_edit.to_dict('records'),city_load_data("SELECT * FROM `airis-rnd-machines.Sample_Data.Cuts_DB`").to_dict('records')) 
    

@app.callback(
    Output("videoid_edit","options"),
    Output("videoid_edit","value"),

    Output("rec_num","value"),

    Input("cities_edit",  "value"),
    State("latest_df",   "data"),

         # <-- NEW
    prevent_initial_call=True
)            

def loading_videoid_options(selected_input,latest_df):

    rec_num=""
    df = pd.DataFrame(latest_df)
    q2_df = df.copy()
    q2_df['base'] = q2_df['Cut_ID'].str.extract(r'^(.*)_v\d+$')[0]

    
    if selected_input in df_city_edit['city'].values:

        video_id_options =  q2_df[q2_df['City']==selected_input]['base'].unique()
        rec_num = q2_df[q2_df['City']==selected_input]['base'].shape[0]
    elif selected_input in q2_df['record_id'].values:
        video_id_options =  q2_df[q2_df['record_id']==selected_input]['base'].unique()
        rec_num = q2_df[q2_df['record_id']==selected_input]['base'].shape[0]
    elif selected_input in q2_df['Analyst'].values:
        video_id_options =  q2_df[q2_df['Analyst']==selected_input]['base'].unique() 
        rec_num = q2_df[q2_df['Analyst']==selected_input]['base'].shape[0] 
    else:
        video_id_options = []

    return (video_id_options,"Select a cut id",rec_num)

@app.callback(
    Output("cut_version","options"),
    Output("cut_version","value"),

    Input("videoid_edit","value"),

    State("latest_df",   "data"),
    State("cities_edit",  "value"),
    
)


def load_versions(cut,df,selected_vid):
    if selected_vid:
        v_df=pd.DataFrame(df)
        if cut:
            cuts_df = v_df[v_df['Cut_ID'].str.contains(cut)].copy()
            cuts_df['version'] = cuts_df['Cut_ID'].str.extract(r'_(v\d+)$')[0]
            version_options = sorted(cuts_df['version'].unique(), key=lambda x: int(x[1:]))  # remove 'v' and sort by int

            ver_val = ""
        else:
            version_options =[]
            ver_val = ""

        return version_options,ver_val
    return [],""

def video_info_extraction(link):
            ydl_opts = {}
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                try:
                    info_dict = ydl.extract_info(link, download=False)
                    video_size = info_dict.get('filesize') or info_dict.get('filesize_approx')
                    og_dur = info_dict.get('duration', 0)
                    if video_size  and og_dur:
                        vid_size = f"{video_size / (1024 * 1024):.2f} MB"
                        video_og_dur = str(timedelta(seconds=og_dur))
                        return vid_size,video_og_dur
                    else:
                        vid_size = 0
                        video_og_dur = 0
                    return vid_size,video_og_dur
                except (yt_dlp.utils.DownloadError, yt_dlp.utils.ExtractorError, Exception) as e:
                    return "", ""
                    
@app.callback(
    Output('og_size_ed','value'),
    Output('og_dur_ed','value'),
    Input('link_url_edit','value'),
    State("videoid_edit","value"),
    State("cut_version","value"),
    State('latest_df','data'),
    State("latest_cut",   "data")
)



def cal_size (link,cut,ver,latest_df,latest_cut):
    from datetime import timedelta

    df = pd.DataFrame(latest_df)
    cuts = pd.DataFrame(latest_cut)


    if link:
        cut_vers = f"{cut}_{ver}"
        match_link = df[df['Cut_ID']==cut_vers]['Links'].values[0]
        if not match_link:
            vid_size,video_og_dur = video_info_extraction(match_link)
            return vid_size,video_og_dur
        else:
            match_dur = cuts[cuts['Cut_ID']==cut_vers]['Video Duration_OG'].values[0]
            match_size = cuts[cuts['Cut_ID']==cut_vers]['Video_Size_OG'].values[0]
            if match_dur and not match_size:
                vid_size,video_og_dur = video_info_extraction(match_link)
                if vid_size:
                    return vid_size,match_dur
                else:
                    return None, match_dur  
            elif not match_dur and match_size:
                vid_size,video_og_dur = video_info_extraction(match_link)
                if video_og_dur:
                    return match_size,video_og_dur
                else:
                    return match_size,None
            elif not match_dur and not match_size:
                vid_size,video_og_dur = video_info_extraction(match_link)
                if vid_size and video_og_dur :
                    return vid_size,video_og_dur
                else:
                    return None, None
            else:
                return match_size,match_dur
    else:
        return "", ""
    
@app.callback ([
        Output('confirmation-modal_edit','is_open'),
        Output('confirmation-message_edit','children'),
        Output("stored-videoid", "data"), 
        Output('sources_edit','value'),    
        Output('link_url_edit','value'),
        Output('coordinates_input_edit','value'),
        Output('input-hours_edit','value'),
        Output('input-minutes_edit','value'),
        Output('input-seconds_edit','value'),
        Output('input-hours_end_edit','value'),
        Output('input-minutes_end_edit','value'),
        Output('input-seconds_end_edit','value'), 
        Output('tod_edit','value'),
        Output('weather_edit','value'),       
        Output('vq_edit','value'),    
        Output('tilt_edit','value'),     
        Output('distance_edit','value'),     
        Output('occlusion_list_edit','value'), 
        Output('terrain_edit','value'),   
        Output('logos_list_edit','value'),
        Output('distortions_list_edit','value'),
        Output('analysts_edit','value'),
        Output('comments_edit','value'), 
        Output('picked_video_edit','url'),
        Output("confirmation-update", "is_open"),
        Output('delete-modal',"is_open"),
        Output('checkbox_edit','value'),
        Output('link_error_edit', 'children'),
        Output('coords_error_ed', 'children'),
        Output('map_edit', 'viewport'),
        Output('map-layer_ed', 'children'),
        Output("cities_edit",  "value" ,allow_duplicate=True),
        Output("latest_df",   "data",allow_duplicate=True),
        Output("latest_cut",   "data",allow_duplicate=True)
        
        
   ],
    [ 
    Input("cities_edit",  "value"),
    Input("videoid_edit","value"),
    Input("cut_version","value"),
    Input('sources_edit','value'),    
    Input('link_url_edit','value'),
    Input('coordinates_input_edit','value'),
    Input('tod_edit','value'),
    Input('weather_edit','value'),       
    Input('vq_edit','value'),    
    Input('tilt_edit','value'),     
    Input('distance_edit','value'),     
    Input('occlusion_list_edit','value'), 
    Input('terrain_edit','value'),   
    Input('logos_list_edit','value'),
    Input('distortions_list_edit','value'),
    Input('analysts_edit','value'),
    Input('comments_edit','value'),
    Input('update','n_clicks'),
    Input("confirm-yes", "n_clicks"),
    Input("confirm-no", "n_clicks"),
    Input('place_map_ed','n_clicks'),
    

           
    ],
[    
 State('output-duration_edit','value'), 
 State('default-values_edit','data'),
 State("stored-videoid", "data"),
 State('latest_df','data'),
 State("confirmation-update", "is_open"),
 State('delete_password','value'),
 State('checkbox_edit','value'),
State('input-hours_edit','value'),
State('input-minutes_edit','value'),
State('input-seconds_edit','value'),
State('input-hours_end_edit','value'),
State('input-minutes_end_edit','value'),
State('input-seconds_end_edit','value'), 
State("og_dur_ed","value"),
State('og_size_ed','value'),
State("latest_cut",   "data"),
State("cut_version","options"),  
],
 prevent_initial_call='initial_duplicate'
               
)
def edit_mode(city_name_edit, video_cut, video_version, sourceedit, linkedit, coord_edit, tod_edit, weather_edit, vq_edit, tilt_edit, distance_edit,
              occlusion_edit, terrain_edit, logos_edit, distortions_edit, analyst_edit, comments_edit, update,confirm_yes,confirm_no,
             check_btn,duration_edit, defaults_edit,stored_videoid,latest_df,update_confirmation,delete_password,checkbox_ed,
              hours_st_edit, minute_st_edit, sec_st_edit,hours_end_edit, min_end_edit, sec_end_edit,og_dur_val,sized,latest_cut,ver_ops):
    ctx = dash.callback_context
    triggered_id = ctx.triggered[0]['prop_id'] if ctx.triggered else None
    df_city_edit = pd.DataFrame(latest_df)
    cut_db_ed = pd.DataFrame(latest_cut)
    # Define fallback/default output with the right length (25 in your case)

    if video_version:
        video_ver = f"{video_cut}_{video_version}"
        city_val = df_city_edit[df_city_edit['Cut_ID'] == video_ver]['City'].values[0]   
    else:
        video_ver = ""
        city_val = ""
    print(video_ver)

    
    if not video_version :
        # Reset all fields to defaults
        return (
            False, dash.no_update, dash.no_update,"","","",0,0,0,0,0,0,"","","","","","","","","","","","",False,False,dash.no_update,dash.no_update,dash.no_update
        ,dash.no_update,[],dash.no_update,dash.no_update,dash.no_update)


                        
    elif triggered_id == 'link_url_edit.value':
        if linkedit:
            try: 
                valid_url_watch = is_valid_url(linkedit)
                if valid_url_watch:
                    picked_video = valid_url_watch
                    return (False, dash.no_update,stored_videoid) + (dash.no_update,) * 20 + (picked_video,False,False,dash.no_update,"",
                    dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update)
            except ValueError as e:
                # If any validation fails, catch and show the error message
                error_input = html.Div(f"Incorrect Link Format", style={"color": "red"})   
                return (False, dash.no_update,stored_videoid) + (dash.no_update,) * 20 + (dash.no_update,False,False,
                dash.no_update,error_input,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update)
        else:
            return (False, dash.no_update,stored_videoid) + (dash.no_update,) * 20 + ("",False,False,dash.no_update,"",dash.no_update,dash.no_update,
            dash.no_update,dash.no_update,dash.no_update,dash.no_update)
            
    elif triggered_id == 'coordinates_input_edit.value':
        if coord_edit:
            try: 
                lat_str, lon_str = coord_edit.split(",")
                # 2) … and 2) both must convert to float
                lat, lon = float(lat_str), float(lon_str)
                marker = dl.Marker(position=[lat, lon],
                                children=[dl.Popup(coord_edit)],
                                id='city-mark')
                viewport = {'center': [lat, lon], 'zoom': 14}
                return (False, dash.no_update,stored_videoid) + (dash.no_update,) * 20 + (dash.no_update,False,False,
                dash.no_update,dash.no_update,"",viewport,[marker],dash.no_update,dash.no_update,dash.no_update)
            except ValueError as e:
                # If any validation fails, catch and show the error message
                error_input_cor = html.Div(f"Incorrect Coordinates Format", style={"color": "red"})
                return (False, dash.no_update,stored_videoid) + (dash.no_update,) * 20 + (dash.no_update,False,False,
                dash.no_update,dash.no_update,error_input_cor,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update)
        else:
            center= cities[cities['City_Name'] == city_name_edit]['CityCenter'].iloc[0]
            lat, lon =map(float, center.split(",")) 
            map_center_city = {'center': [lat, lon], 'zoom': 10}      
            return (False, dash.no_update,stored_videoid) + (dash.no_update,) * 20 + (dash.no_update,False,False,dash.no_update,dash.no_update
            ,"",map_center_city,[],dash.no_update,dash.no_update,dash.no_update)


    elif triggered_id == 'place_map_ed.n_clicks':
        try:
            lat_str, lon_str = coord_edit.split(",")
            # 2) … and 2) both must convert to float
            lat, lon = float(lat_str), float(lon_str)
            if not coord_edit or not city_name_edit:
                raise ValueError('Please insert both coordinates & city name!')
            
            polygodid = cities[cities['City_Name'] == city_name_edit]['PolygonID'].values[0]
            request = drive_service.files().get_media(fileId=polygodid)
            polygon_bytes = request.execute()

            try:
                if isinstance(polygon_bytes, bytes):
                    polygon_data = json.loads(polygon_bytes.decode('utf-8'))
                else:
                    polygon_data = json.loads(polygon_bytes)
            except Exception:
                polygon_data = []
            poly_coords = [tuple(coord) for coord in polygon_data]
   

            if is_inside_any(lat, lon, poly_coords):
                validation_msg = html.Div(
                    [
                        html.H5("✅ Success", style={"color": "green"}),
                        html.P(f"{coord_edit} is in the Polygon", style={"color": "green", "font-weight": "bold"})
                    ]
                )
            else:
                validation_msg = html.Div(
                    [
                        html.H5("❌ Warning", style={"color": "red"}),
                        html.P(f"{coord_edit} is out of the Polygon", style={"color": "red", "font-weight": "bold"})
                    ]
                )

            marker = dl.Marker(
                position=[lat, lon],
                children=[dl.Popup(coord_edit)],
                id='city-mark'
            )

            viewport = {'center': [lat, lon], 'zoom': 14}
            return (True, validation_msg,stored_videoid) + (dash.no_update,) * 20 + (dash.no_update,False,False,dash.no_update,
            dash.no_update,"",viewport,[marker],dash.no_update,dash.no_update,dash.no_update)


        except ValueError as e:
            error_message = html.Div(
                [
                    html.H5("⚠️ Validation Error", style={"color": "red"}),
                    html.P(str(e), style={"color": "black"})
                ]
            )
            return (True, validation_msg,stored_videoid) + (dash.no_update,) * 20 + (dash.no_update,False,False,dash.no_update,dash.no_update,
            "",viewport,[marker],dash.no_update,dash.no_update,dash.no_update)

    
    elif  triggered_id == 'cut_version.value':
        row = df_city_edit[df_city_edit['Cut_ID'] == video_ver]
        if not row.empty:
            time_st = row['Start_Time'].values[0]
            hh_st, mm_st, ss_st = parse_time_string(time_st)

            time_end = row['Finish_Time'].values[0]
            hh_end, mm_end, ss_end = parse_time_string(time_end)

            value_check=['on'] if row['Duration'].iloc[0] == 'Full Video' else []
            
            coord_outputs = row['Coordinates'].values[0]
            lat_str_l, lon_str_l = coord_outputs.split(",")
            lat, lon = float(lat_str_l), float(lon_str_l)
            marker = dl.Marker(position=[lat, lon],
                            children=[dl.Popup(coord_outputs)],
                            id='city-mark')
            viewport = {'center': [lat, lon], 'zoom': 14}
            edit_title = row['Title'].values[0]
            return (
                False, dash.no_update, city_name_edit,
                row['Source'].values[0],
                row['Links'].values[0],
                row['Coordinates'].values[0],
                hh_st, mm_st, ss_st,
                hh_end, mm_end, ss_end,
                row['Time_of_the_day'].values[0],
                row['Weather'].values[0],
                row['Video_quality'].values[0],
                row['Camera_tilt'].values[0],
                row['Distance_from_building'].values[0],
                row['Occluded'].values[0],
                row['Terrain'].values[0],
                row['Logos_and_text'].values[0],
                row['Distortions'].values[0],
                row['Analyst'].values[0],
                row['Comments'].values[0] if row['Comments'].values[0] else "",
                row['Links'].values[0],False,False,value_check,dash.no_update,dash.no_update,viewport,[marker],dash.no_update,dash.no_update,dash.no_update
            )
      
        return (False, dash.no_update,"", "","","",0,0,0,0,0,0,"","","","","","","","","","","","",
                False,False,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update)
   
    elif triggered_id == 'update.n_clicks':
        last_ver = ver_ops[-1]
        print(last_ver,video_version)
        try:
            if video_version  == last_ver:
                return (False, dash.no_update,stored_videoid) + (dash.no_update,) * 21 + (True,False,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update)
            else:
                raise ValueError("Make sure you edit the latest version!")  
        except ValueError as e:              
            error_message = html.Div(
                [
                    html.H5("⚠️ Validation Error", style={"color": "red"}),
                    html.P(str(e), style={"color": "black"})
                ]
            )
            return(True, error_message,stored_videoid) + (dash.no_update,) * 21 + (False,False,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,)
    
    
    elif triggered_id =='confirm-yes.n_clicks' :
        try:
            general_validations_update = general_validations (analyst_edit,city_name_edit,distance_edit,edit_title,occlusion_edit,
            terrain_edit,logos_edit,duration_edit, tod_edit,weather_edit,vq_edit,tilt_edit,sourceedit)
            if linkedit != df_city_edit[df_city_edit['Cut_ID'] == video_ver]["Links"].values[0]:
                valid_url_update = is_valid_url(linkedit)   
            else:
                valid_url_update = linkedit     
                    
            valid_coordinates_update = valid_coords(coord_edit)
            valid_duration_update = valid_dur(duration_edit)

            if not checkbox_ed:
                hours_st = minute_st_edit // 60
                minutes_st = minute_st_edit % 60
                start_time_edit = f"{hours_st:02}:{minutes_st:02}:{sec_st_edit:02}"
                hours = min_end_edit // 60
                minutes = min_end_edit % 60
                end_time_edit = f"{hours:02}:{minutes:02}:{sec_end_edit:02}"
                h, m, s = map(int, duration_edit.split(":"))
                dur_time =  f"{h:02}:{m:02}:{s:02}"
            else:
                start_time_edit =f"0:00"
                end_time_edit=f"0:00"
                dur_time= duration_edit

            df_city_edit['base'] = df_city_edit['Cut_ID'].str.extract(r'^(.*)_v\d+$')[0]
            other_rows = df_city_edit[df_city_edit['base'] != video_cut]

            # Check if the new URL and Coordinates pair exists elsewhere
            duplicate_match = other_rows[
                (other_rows['Links'] == valid_url_update)]

            if not duplicate_match.empty:
                if valid_coordinates_update in duplicate_match['Coordinates'].values:
                    raise ValueError("Video link and Coordinates already exist in another entry!")
                
                video_name_edit = df_city_edit[
                    df_city_edit['Links'] == valid_url_update
                ]['Title'].values[0]
                duplicate_match = duplicate_match.copy()  # Safely modify

                time_to_check_ed = parse_time(start_time_edit)
                duplicate_match['Start Time Parsed'] = duplicate_match['Start_Time'].apply(parse_time)
                duplicate_match['Finish Time Parsed'] = duplicate_match['Finish_Time'].apply(parse_time)

                dur_dup = duplicate_match.apply(
                    lambda row: row['Start Time Parsed'] <= time_to_check_ed <= row['Finish Time Parsed'],
                    axis=1
                )

                full_video_cross = duplicate_match.apply(
                    lambda row: row['Duration'] == "Full Video" ,
                    axis=1
                )
                if dur_dup.any() or full_video_cross.any():
                    raise ValueError("There's already this video with another crossing timing, please select another duration!")
                
            else:                
                if valid_url_update not in df_city_edit['Links'].values:  
                    if 'youtube' in valid_url_update and 'Youtube' in sourceedit:
                        with yt_dlp.YoutubeDL() as ydl:
                            info_dict = ydl.extract_info(valid_url_update, download=False)
                            video_name_edit = info_dict.get('title', 'No title found')
                    elif 'tiktok' in valid_url_update and 'Tiktok' in sourceedit:
                        with yt_dlp.YoutubeDL() as ydl:
                            info_dict = ydl.extract_info(valid_url_update, download=False)
                            video_name_edit = info_dict.get('title', 'No title found')
                            
                    elif 'facebook' in valid_url_update and 'facebook' in sourceedit:
                        with yt_dlp.YoutubeDL() as ydl:
                            info_dict = ydl.extract_info(valid_url_update, download=False)
                            video_name_edit = info_dict.get('title', 'No title found')
                    else:
                        raise ValueError("Video title not found - maybe not a matching source?")  
                    
                video_name_edit = df_city_edit[
                    df_city_edit['Links'] == valid_url_update]['Title'].values[0]
   
            video_og_dur = df_city_edit[
                    df_city_edit['Links'] == valid_url_update
                ]['original_duration'].values[0]
            
            updated_rec_id = df_city_edit[
                    df_city_edit['Links'] == valid_url_update
                ]['record_id'].values[0]
            
            updated_country = df_city_edit[
                    df_city_edit['Links'] == valid_url_update
                ]['country'].values[0] 
            
            from datetime import datetime
            import pytz

            local_tz = pytz.timezone("Asia/Jerusalem")
            local_dt = datetime.now(local_tz)  # already in GMT+3 if DST applies
            formatted_datetime = local_dt.strftime("%Y-%m-%d %H:%M:%S")             
            
            match = re.match(r'^(.*)_v\d+$', video_ver)

            if match:
                cleaned_cut = match.group(1)
            else:
                cleaned_cut = video_ver  # fallback if no match
                 
            df_city_edit['base'] = df_city_edit['Cut_ID'].str.extract(r'^(.*)_v\d+$')[0]
            filt_clean = df_city_edit[df_city_edit['base'] == cleaned_cut]
            new_v = filt_clean.shape[0] + 1
            new_cut_v = f"{cleaned_cut}_v{new_v}"

            
            selected_inputs =[video_ver,updated_rec_id,updated_country,city_val, valid_url_update,video_name_edit,
            video_og_dur,sourceedit,valid_coordinates_update,start_time_edit,end_time_edit,
            dur_time,analyst_edit,tod_edit,terrain_edit,weather_edit,vq_edit,tilt_edit,distance_edit,
            occlusion_edit,distortions_edit,logos_edit,comments_edit]
            
            cut_ver_df = df_city_edit[df_city_edit['Cut_ID'] == video_ver].copy()
            
            mask = cut_ver_df.apply(lambda row: all(val in row.values for val in selected_inputs), axis=1)
            if mask.iloc[0]:
                raise ValueError ("Please change values to proceed!")
            latest_index = int(df_city_edit['Index'].iloc[-1]) + 1
            values_update= [latest_index,new_cut_v,updated_rec_id,updated_country,city_val, valid_url_update,video_name_edit,
            valid_coordinates_update,analyst_edit,sourceedit,video_og_dur,start_time_edit,end_time_edit,
            dur_time,tod_edit,terrain_edit,weather_edit,vq_edit,tilt_edit,distance_edit,
            occlusion_edit,distortions_edit,logos_edit,comments_edit,formatted_datetime]  

            
            try:              
                
                append_row_to_bq(values_update, table_id="airis-rnd-machines.Sample_Data.Geo_App_DB")
                # --- insert the new version into geo_cut ---

                latest_cut_index = int(cut_db_ed['Index'].iloc[-1]) + 1

                og_dured = df_city_edit[df_city_edit['Cut_ID'] == video_ver]['Original_Duration'].values[0]
                if not og_dured and not og_dur_val:
                    raise ValueError("Please insert original video duration")
                

                
                if not og_dured and og_dur_val:
                    og_dured = og_dur_val
                # Parse all the components as ints
                components = list(map(int, og_dured.split(":")))

                # Compute total seconds
                if len(components) == 3:
                    hours, mins, secs = components
                elif len(components) == 2:
                    mins, secs = components
                    hours = 0
                else:
                    raise ValueError(
                        "Original duration must be in H:MM:SS or MM:SS format"
                    )

                total_seconds = hours*3600 + mins*60 + secs

                # Re‐format as M:SS
                minutes = total_seconds // 60
                seconds = total_seconds % 60
                formatted_dured = f"{minutes}:{seconds:02d}"

                geo_cut_row = [
                    latest_cut_index,        # Index
                    new_cut_v,               # Cut_ID
                    updated_country,         # Country
                    city_val,                # City
                    valid_url_update,        # Links
                    video_name_edit,         # Title
                    'TBD',                   # Annotated File Name
                    start_time_edit,         # Cut_Start
                    end_time_edit,           # Cut_Finish
                    dur_time,                # Cut_Duration
                    'TBD',                   # Cut_Size
                    'TBD',                   # GCP_Bucket_URL
                    'FALSE',                 # Ignored (new version stays active)
                    analyst_edit,            # Validated_By
                    None,      # Upload_Time
                    sized,              # Video_Size_OG
                    formatted_dured                     # Video Duration_OG
                ]
                append_row_to_bq(geo_cut_row, table_id="airis-rnd-machines.Sample_Data.Cuts_DB")

                # --- mark all previous versions as ignored ---
                client = bigquery.Client()

                # First UPDATE: mark all previous versions as ignored
                query1 = """
                    UPDATE `airis-rnd-machines.Sample_Data.Cuts_DB`
                    SET Ignored = TRUE
                    WHERE Cut_ID != @new_cut_v
                    AND Cut_ID LIKE @like_pattern
                """

                job_config1 = bigquery.QueryJobConfig(
                    query_parameters=[
                        bigquery.ScalarQueryParameter("new_cut_v", "STRING", new_cut_v),
                        bigquery.ScalarQueryParameter("like_pattern", "STRING", f"{cleaned_cut}_v%"),
                    ]
                )

                client.query(query1, job_config=job_config1).result()

                # Second UPDATE: set Validated_By for other versions
                query2 = """
                    UPDATE `airis-rnd-machines.Sample_Data.Cuts_DB`
                    SET Validated_By = @analyst_edit
                    WHERE Cut_ID LIKE @like_pattern
                    AND Cut_ID != @new_cut_v
                """

                job_config2 = bigquery.QueryJobConfig(
                    query_parameters=[
                        bigquery.ScalarQueryParameter("analyst_edit", "STRING", analyst_edit),
                        bigquery.ScalarQueryParameter("like_pattern", "STRING", f"{cleaned_cut}_v%"),
                        bigquery.ScalarQueryParameter("new_cut_v", "STRING", new_cut_v),
                    ]
                )

                client.query(query2, job_config=job_config2).result()



            except Exception as e:
                error_window_update = html.Div([
                html.H5("⚠️ Update Failed", style={"color": "red"}),
                html.P(f"Could not update the database: {e}", style={"color": "black"})
             ])
                
            
                # Return the error window and leave everything else unchanged
                return (
                    True,                      # keep the update dialog open
                    error_window_update,       # show our new error
                    stored_videoid,            # keep current selection
                    *([dash.no_update] * 21),  # no other fields change
                    False,False,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update                     # disable Confirm button
                ,dash.no_update,dash.no_update,dash.no_update)
            
            #center= cities[cities['City Name'] == city_val]['CityCenter'].iloc[0]
            center = "41.8921503,12.4787812"
            lat, lon =map(float, center.split(",")) 
            map_center_city = {'center': [lat, lon], 'zoom': 10} 
                            
            result_window_update = html.Div([
                html.H1('Video Updated Successfully!'),
                html.Br(),
                html.H3("Video Details: "),
                html.Ul([
                    html.Li(f"City: {city_name_edit}"),
                    html.Li(f"Cut ID: {new_cut_v}"),
                    html.Li(f"Video Link: {valid_url_update}"),
                    html.Li(f"Video Name: {video_name_edit}"),
                    html.Li(f"Video Source: {sourceedit}"),                    
                    html.Li(f"Coordinates: {valid_coordinates_update}"),
                    html.Li(f"Start Time: {start_time_edit}"),
                    html.Li(f"Start Time: {end_time_edit}"),                    
                    html.Li(f"Video Duration: {valid_duration_update}"),
                    html.Li(f"Analyst: {analyst_edit}"),
                    html.Li(f"Time of the day: {tod_edit}"),
                    html.Li(f"Weather: {weather_edit}"), 
                    html.Li(f"Video Quality: {vq_edit}"), 
                    html.Li(f"Camera Tilt: {tilt_edit}"),
                    html.Li(f"Distance from a building: {distance_edit}"),
                    html.Li(f"Occlusion: {occlusion_edit}"),                                         
                    html.Li(f"Terrain: {terrain_edit}"),
                    html.Li(f"Logos and Text: {logos_edit}"),
                    html.Li(f"Distortions: {distortions_edit}"),
                    html.Li(f"Comments: {comments_edit}")                                                                    
                ])
            ])
            df1 = city_load_data("SELECT * FROM `airis-rnd-machines.Sample_Data.Geo_App_DB`")
            df2 = city_load_data("SELECT * FROM `airis-rnd-machines.Sample_Data.Cuts_DB`")
            checkbox_ed =[]  
            return (True,result_window_update,"", "","","",0,0,0,0,0,0,"","","",
                    "","","","","","","","","",False,False,checkbox_ed,
            dash.no_update,dash.no_update,map_center_city,[],"",df1.to_dict("records"),df2.to_dict("records"))      
        except ValueError as e:
            # If any validation fails, catch and show the error message
            error_message = html.Div(
                [
                    html.H5("⚠️ Validation Error", style={"color": "red"}),
                    html.P(str(e), style={"color": "black"})
                ]
            )
            return(True, error_message,stored_videoid) + (dash.no_update,) * 21 + (False,False,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,)
    
    elif triggered_id == 'delete.n_clicks':
        if stored_videoid:
            return (False, dash.no_update,stored_videoid) + (dash.no_update,) * 21 + (False,True,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,)
        else:
            raise ValueError("No  selected to remove!")
        
    elif triggered_id == 'delete_btn.n_clicks':
        if delete_password == "delete":
            try:

                
                center= cities[cities['City_Name'] == city_val]['CityCenter'].iloc[0]
                lat, lon =map(float, center.split(",")) 
                map_center_city = {'center': [lat, lon], 'zoom': 10} 
                remove_record_bq(video_ver,table_id="airis-rnd-machines.Sample_Data.Geo_App_DB")
                
                print(video_ver)
                    
                query1 = """
                    UPDATE `airis-rnd-machines.Sample_Data.Cuts_DB`
                    SET Ignored = TRUE
                    WHERE Cut_ID = @cut_id
                """

                # Define the query to set Validated_By
                query2 = """
                    UPDATE `airis-rnd-machines.Sample_Data.Cuts_DB`
                    SET Validated_By = @validated_by
                    WHERE Cut_ID = @cut_id
                """

                # Prepare parameters
                job_config1 = bigquery.QueryJobConfig(
                    query_parameters=[
                        bigquery.ScalarQueryParameter("Cut_ID", "STRING", video_ver),
                    ]
                )

                job_config2 = bigquery.QueryJobConfig(
                    query_parameters=[
                        bigquery.ScalarQueryParameter("Validated_By", "STRING", analyst_edit),
                        bigquery.ScalarQueryParameter("Cut_ID", "STRING", video_ver),
                    ]
                )

                # Run the update queries
                client.query(query1, job_config=job_config1).result()
                client.query(query2, job_config=job_config2).result()


                df1 = city_load_data("SELECT * FROM `airis-rnd-machines.Sample_Data.Geo_App_DB`")
                df2 = city_load_data("SELECT * FROM `airis-rnd-machines.Sample_Data.Cuts_DB`")
                
                df3 = df2[df2['Cut_ID'].str.contains(video_cut)].copy()
                if df3.shape[0] >= 2:
                    
                    cut_v = df3[df3['Ignored'] == 'true']['Cut_ID'].iloc[-1]

                    client = bigquery.Client()

                    # First UPDATE: Unmark "Ignored"
                    query1 = """
                        UPDATE `airis-rnd-machines.Sample_Data.Cuts_DB`
                        SET Ignored = FALSE
                        WHERE Cut_ID = @cut_v
                    """

                    job_config1 = bigquery.QueryJobConfig(
                        query_parameters=[
                            bigquery.ScalarQueryParameter("cut_v", "STRING", cut_v),
                        ]
                    )

                    client.query(query1, job_config=job_config1).result()

                    # Second UPDATE: Set "Validated_By"
                    query2 = """
                        UPDATE `airis-rnd-machines.Sample_Data.Cuts_DB`
                        SET Validated_By = @analyst_edit
                        WHERE Cut_ID = @cut_v
                    """

                    job_config2 = bigquery.QueryJobConfig(
                        query_parameters=[
                            bigquery.ScalarQueryParameter("analyst_edit", "STRING", analyst_edit),
                            bigquery.ScalarQueryParameter("cut_v", "STRING", cut_v),
                        ]
                    )

                    client.query(query2, job_config=job_config2).result()
                
                result_removal = f"{video_ver} has successfully removed !"

                return (True,result_removal,"Select a video id", "","","",0,0,0,0,0,0,"","","","","","","","","","","","",
            False,False,dash.no_update,dash.no_update,dash.no_update,map_center_city,[],"",df1.to_dict("records"),df2.to_dict("records"))   
            except Exception as e:
                # Build a Dash error window if the Sheets update fails
                error_window_update = html.Div([
                    html.H5("⚠️ Deletion Failed", style={"color": "red"}),
                    html.P(f"Could not update the sheet: {e}", style={"color": "black"})
                ])
                # Return the error window and leave everything else unchanged
                return (
                    True,                      # keep the update dialog open
                    error_window_update,       # show our new error
                    stored_videoid,            # keep current selection
                    *([dash.no_update] * 21),  # no other fields change
                    False,False,dash.no_update,dash.no_update,dash.no_update,
                    dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update,                     # disable Confirm button
                )
            
      
        else:
            result_removal = "Incorrect Password, please try again!"
            return (True,result_removal,stored_videoid) + (dash.no_update,) * 21 + (False,False,dash.no_update,dash.no_update,dash.no_update,
            dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update)        
      

    # No videoid selected, just update options
    return (False, dash.no_update,stored_videoid) + (dash.no_update,) * 21 + (False,False,dash.no_update,dash.no_update,dash.no_update,
    dash.no_update,dash.no_update,dash.no_update,dash.no_update,dash.no_update)







 # Define the main layout with tabs
app.layout = html.Div(
    [
        dcc.Tabs(id='tabs', value='tab1', children=[
                dcc.Tab(
                    label='Geo-Tag Form',
                    children=insert_tab_layout(),
                    style=tab_style,
                    selected_style=selected_tab_style,
                    value='tab1'),
                dcc.Tab(
                    label='Geo-Tag Edit Mode',
                    children=edit_tab_layout(),
                    style=tab_style,
                    selected_style=selected_tab_style,
                    value='tab2'),
                

            ],
        ),
    ]
)                 
             
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000, debug=True)
